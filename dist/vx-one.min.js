!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("vx",[],t):"object"==typeof exports?exports.vx=t():e.vx=t()}(self,(function(){return(()=>{"use strict";var __webpack_modules__={775:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Camera": () => /* reexport */ src_Camera,\n  "Container": () => /* reexport */ src_Container,\n  "Game": () => /* reexport */ src_Game,\n  "Graph": () => /* reexport */ Graph,\n  "Rect": () => /* reexport */ src_Rect,\n  "Scale": () => /* reexport */ Scale,\n  "Scene": () => /* reexport */ src_Scene,\n  "Sprite": () => /* reexport */ src_Sprite,\n  "State": () => /* reexport */ State,\n  "Text": () => /* reexport */ src_Text,\n  "TextureManager": () => /* reexport */ src_TextureManager,\n  "TileMap": () => /* reexport */ src_TileMap,\n  "math": () => /* reexport */ utils,\n  "wallslide": () => /* reexport */ src_wallslide\n});\n\n;// CONCATENATED MODULE: ./src/Container.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Container = /*#__PURE__*/function () {\n  function Container() {\n    _classCallCheck(this, Container);\n\n    this.pos = {\n      x: 0,\n      y: 0\n    };\n    this.children = [];\n  }\n\n  _createClass(Container, [{\n    key: "update",\n    value: function update(dt, t) {\n      var _this = this;\n\n      this.children = this.children.filter(function (child) {\n        if (child.update) {\n          child.update(dt, t, _this);\n        }\n\n        return child.dead ? false : true;\n      });\n    }\n  }, {\n    key: "add",\n    value: function add(child) {\n      this.children.push(child);\n      return child;\n    }\n  }, {\n    key: "remove",\n    value: function remove(child) {\n      this.children = this.children.filter(function (c) {\n        return c !== child;\n      });\n      return child;\n    }\n  }, {\n    key: "map",\n    value: function map(f) {\n      return this.children.map(f);\n    }\n  }]);\n\n  return Container;\n}();\n\n/* harmony default export */ const src_Container = (Container);\n;// CONCATENATED MODULE: ./src/Constants.js\nvar Scale = {\n  NONE: 0,\n  RESIZE: 1\n};\nvar State = {\n  NONE: 0,\n  LOADING: 1,\n  READY: 2,\n  RUNNING: 3,\n  SLEEPING: 4\n};\nvar Graph = {\n  RECT: 0,\n  RECT_OUTLINE: 1\n};\n\n;// CONCATENATED MODULE: ./src/Scene.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction Scene_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Scene_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Scene_createClass(Constructor, protoProps, staticProps) { if (protoProps) Scene_defineProperties(Constructor.prototype, protoProps); if (staticProps) Scene_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar Scene = /*#__PURE__*/function (_Container) {\n  _inherits(Scene, _Container);\n\n  var _super = _createSuper(Scene);\n\n  function Scene(key) {\n    var _this;\n\n    var isActive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    Scene_classCallCheck(this, Scene);\n\n    _this = _super.call(this);\n    _this.key = key;\n    _this.active = isActive;\n    _this.state = State.NONE;\n    _this.controls;\n    return _this;\n  }\n\n  Scene_createClass(Scene, [{\n    key: "getBounds",\n    value: function getBounds(entity) {\n      var hitBox = entity.hitBox,\n          pos = entity.pos;\n      var hit = hitBox;\n      return {\n        x: hit.x + pos.x,\n        y: hit.y + pos.y,\n        w: hit.w - 1,\n        h: hit.h - 1\n      };\n    }\n  }, {\n    key: "isOvelapping",\n    value: function isOvelapping(e1, e2) {\n      var a = this.getBounds(e1);\n      var b = this.getBounds(e2);\n      return a.x <= b.x + b.w && a.x + a.w >= b.x && a.y <= b.y + b.h && a.y + a.h >= b.y;\n    }\n  }]);\n\n  return Scene;\n}(src_Container);\n\n/* harmony default export */ const src_Scene = (Scene);\n;// CONCATENATED MODULE: ./src/GameObject.js\nfunction GameObject_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar GameObject = function GameObject() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n  GameObject_classCallCheck(this, GameObject);\n\n  this.name = name;\n  this.pos = {\n    x: 0,\n    y: 0\n  };\n  this.scale = {\n    x: 1,\n    y: 1\n  };\n  this.anchor = {\n    x: 0,\n    y: 0\n  };\n  this.pivot = {\n    x: 0,\n    y: 0\n  };\n  this.rotation = 0;\n  this.visible = true;\n  this.zIndex = 1;\n};\n\n/* harmony default export */ const src_GameObject = (GameObject);\n;// CONCATENATED MODULE: ./src/AnimManager.js\nfunction AnimManager_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimManager_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimManager_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimManager_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimManager_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Anim = /*#__PURE__*/function () {\n  function Anim(frames, rate) {\n    AnimManager_classCallCheck(this, Anim);\n\n    this.frames = frames;\n    this.rate = rate;\n    this.reset();\n  }\n\n  AnimManager_createClass(Anim, [{\n    key: "reset",\n    value: function reset() {\n      this.frame = this.frames[0];\n      this.curFrame = 0;\n      this.curTime = 0;\n    }\n  }, {\n    key: "update",\n    value: function update(dt) {\n      var rate = this.rate,\n          frames = this.frames;\n\n      if ((this.curTime += dt) > rate) {\n        this.curFrame++;\n        this.frame = frames[this.curFrame % frames.length];\n        this.curTime -= rate;\n      }\n    }\n  }]);\n\n  return Anim;\n}();\n\nvar AnimManager = /*#__PURE__*/function () {\n  function AnimManager() {\n    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      x: 0,\n      y: 0\n    };\n\n    AnimManager_classCallCheck(this, AnimManager);\n\n    this.anims = {};\n    this.running = false;\n    this.frameSource = e.frame || e;\n    this.current = null;\n  }\n\n  AnimManager_createClass(AnimManager, [{\n    key: "add",\n    value: function add(name, frames, speed) {\n      this.anims[name] = new Anim(frames, speed);\n      return this.anims[name];\n    }\n  }, {\n    key: "update",\n    value: function update(dt) {\n      var current = this.current,\n          anims = this.anims,\n          frameSource = this.frameSource;\n\n      if (!current) {\n        return;\n      }\n\n      var anim = anims[current];\n      anim.update(dt); // Sync the tileSprite frame\n\n      frameSource.x = anim.frame.x;\n      frameSource.y = anim.frame.y;\n    }\n  }, {\n    key: "play",\n    value: function play(anim) {\n      var current = this.current,\n          anims = this.anims;\n\n      if (anim === current) {\n        return;\n      }\n\n      this.current = anim;\n      anims[anim].reset();\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this.current = null;\n    }\n  }]);\n\n  return AnimManager;\n}();\n\n/* harmony default export */ const src_AnimManager = (AnimManager);\n;// CONCATENATED MODULE: ./src/utils.js\nfunction randf(min, max) {\n  if (max == null) {\n    max = min || 1;\n    min = 0;\n  }\n\n  return Math.random() * (max - min) + min;\n}\n\nfunction rand(min, max) {\n  return Math.floor(randf(min, max));\n}\n\nfunction clamp(x, min, max) {\n  return Math.max(min, Math.min(x, max));\n}\n\nfunction randOneFrom(items) {\n  return items[rand(items.length)];\n}\n\nfunction randOneIn() {\n  var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n  return rand(0, max) === 0;\n}\n\nfunction flipAnchor(flipped, frame, scale, origin) {\n  var anchor;\n\n  if (flipped) {\n    if (origin.x === 0) anchor = frame.w * Math.abs(scale.x);else if (origin.x === 1) anchor = 0;\n  } else {\n    if (origin.x === 0) anchor = 0;else if (origin.x === 1) anchor = -(frame.w * Math.abs(scale.x));\n  }\n\n  return anchor;\n}\n\n/* harmony default export */ const utils = ({\n  rand: rand,\n  randf: randf,\n  clamp: clamp,\n  randOneFrom: randOneFrom,\n  randOneIn: randOneIn\n});\n\n;// CONCATENATED MODULE: ./src/Sprite.js\nfunction Sprite_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Sprite_typeof = function _typeof(obj) { return typeof obj; }; } else { Sprite_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Sprite_typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Sprite_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Sprite_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Sprite_createClass(Constructor, protoProps, staticProps) { if (protoProps) Sprite_defineProperties(Constructor.prototype, protoProps); if (staticProps) Sprite_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Sprite_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Sprite_setPrototypeOf(subClass, superClass); }\n\nfunction Sprite_setPrototypeOf(o, p) { Sprite_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Sprite_setPrototypeOf(o, p); }\n\nfunction Sprite_createSuper(Derived) { var hasNativeReflectConstruct = Sprite_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Sprite_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Sprite_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Sprite_possibleConstructorReturn(this, result); }; }\n\nfunction Sprite_possibleConstructorReturn(self, call) { if (call && (Sprite_typeof(call) === "object" || typeof call === "function")) { return call; } return Sprite_assertThisInitialized(self); }\n\nfunction Sprite_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Sprite_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Sprite_getPrototypeOf(o) { Sprite_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Sprite_getPrototypeOf(o); }\n\n\n\n\n\nvar Sprite = /*#__PURE__*/function (_GameObject) {\n  Sprite_inherits(Sprite, _GameObject);\n\n  var _super = Sprite_createSuper(Sprite);\n\n  function Sprite() {\n    var _this;\n\n    var texture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var hasAnim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    Sprite_classCallCheck(this, Sprite);\n\n    _this = _super.call(this);\n    _this.texture = texture;\n    _this.flipped = {\n      x: false,\n      y: false\n    };\n    _this.body = {};\n    _this.origin = {\n      x: 0,\n      y: 0\n    };\n\n    if (hasAnim) {\n      _this.frame = {\n        x: 0,\n        y: 0,\n        w: texture.width,\n        h: texture.height\n      };\n      _this.anims = new src_AnimManager(Sprite_assertThisInitialized(_this));\n    }\n\n    return _this;\n  }\n\n  Sprite_createClass(Sprite, [{\n    key: "setOrigin",\n    value: function setOrigin(x, y) {\n      var anchor = this.anchor,\n          frame = this.frame;\n\n      var _y = y || x;\n\n      anchor.x = -(frame.w * x);\n      anchor.y = -(frame.h * _y);\n      this.origin = {\n        x: x,\n        y: _y\n      };\n    }\n  }, {\n    key: "setScale",\n    value: function setScale(x, y) {\n      var scale = this.scale,\n          anchor = this.anchor;\n\n      var _y = y || x;\n\n      scale.x = Math.abs(x);\n      scale.y = Math.abs(_y); //fix anchor        \n\n      anchor.x = anchor.x * scale.x;\n      anchor.y = anchor.y * scale.y;\n    }\n  }, {\n    key: "flip",\n    value: function flip(fx) {\n      var fy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var scale = this.scale,\n          anchor = this.anchor,\n          frame = this.frame,\n          origin = this.origin;\n      this.flipped.x = fx;\n      this.flipped.y = fy;\n      var fxNo = fx ? -1 : 1;\n\n      if (fx) {\n        scale.x = fxNo * Math.abs(scale.x);\n        if (origin.x === 0 || origin.x === 1) anchor.x = flipAnchor(true, frame, scale, origin);\n      } else {\n        scale.x = fxNo * Math.abs(scale.x);\n        if (origin.x === 0 || origin.x === 1) anchor.x = flipAnchor(false, frame, scale, origin);\n      }\n\n      if (origin.x > 0 && origin.x < 1) anchor.x = scale.x > 0 ? -Math.abs(anchor.x) : Math.abs(anchor.x); // It needs to be improved, just works to flip x \n    }\n  }, {\n    key: "update",\n    value: function update(dt) {\n      if (this.anims) this.anims.update(dt);\n    }\n  }, {\n    key: "hitBox",\n    set: function set(_ref) {\n      var x = _ref.x,\n          y = _ref.y,\n          w = _ref.w,\n          h = _ref.h;\n      this.body = {\n        x: x,\n        y: y,\n        w: w,\n        h: h\n      };\n    },\n    get: function get() {\n      var anchor = this.anchor,\n          body = this.body,\n          scale = this.scale,\n          frame = this.frame,\n          flipped = this.flipped,\n          origin = this.origin;\n      var x, y;\n      x = Math.abs(body.x * scale.x);\n      y = Math.abs(body.y * scale.y);\n      var anchorX = anchor.x;\n\n      if (origin.x === 0 || origin.x === 1) {\n        var scaleClone = _objectSpread(_objectSpread({}, scale), {}, {\n          x: Math.abs(scale.x)\n        });\n\n        anchorX = flipAnchor(false, frame, scaleClone, origin);\n        x = x + anchorX;\n      } else {\n        if (anchorX !== 0) x = x + anchorX * (flipped.x ? -1 : 1);\n      }\n\n      if (anchor.y !== 0) y = y + anchor.y;\n      return {\n        x: x,\n        y: y,\n        w: Math.abs(body.w * scale.x),\n        h: Math.abs(body.h * scale.y)\n      };\n    }\n  }]);\n\n  return Sprite;\n}(src_GameObject);\n\n/* harmony default export */ const src_Sprite = (Sprite);\n;// CONCATENATED MODULE: ./src/TileSprite.js\nfunction TileSprite_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { TileSprite_typeof = function _typeof(obj) { return typeof obj; }; } else { TileSprite_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return TileSprite_typeof(obj); }\n\nfunction TileSprite_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TileSprite_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TileSprite_createClass(Constructor, protoProps, staticProps) { if (protoProps) TileSprite_defineProperties(Constructor.prototype, protoProps); if (staticProps) TileSprite_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction TileSprite_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) TileSprite_setPrototypeOf(subClass, superClass); }\n\nfunction TileSprite_setPrototypeOf(o, p) { TileSprite_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TileSprite_setPrototypeOf(o, p); }\n\nfunction TileSprite_createSuper(Derived) { var hasNativeReflectConstruct = TileSprite_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TileSprite_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TileSprite_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TileSprite_possibleConstructorReturn(this, result); }; }\n\nfunction TileSprite_possibleConstructorReturn(self, call) { if (call && (TileSprite_typeof(call) === "object" || typeof call === "function")) { return call; } return TileSprite_assertThisInitialized(self); }\n\nfunction TileSprite_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TileSprite_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TileSprite_getPrototypeOf(o) { TileSprite_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TileSprite_getPrototypeOf(o); }\n\n\n\nvar TileSprite = /*#__PURE__*/function (_GameObject) {\n  TileSprite_inherits(TileSprite, _GameObject);\n\n  var _super = TileSprite_createSuper(TileSprite);\n\n  function TileSprite() {\n    var _this;\n\n    var texture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    TileSprite_classCallCheck(this, TileSprite);\n\n    _this = _super.call(this);\n    _this.texture = texture;\n    _this.frame = {\n      x: 0,\n      y: 0,\n      w: texture.width,\n      h: texture.height\n    };\n    return _this;\n  }\n\n  TileSprite_createClass(TileSprite, [{\n    key: "w",\n    get: function get() {\n      return this.frame.w * Math.abs(this.scale.x);\n    }\n  }, {\n    key: "h",\n    get: function get() {\n      return this.frame.h * Math.abs(this.scale.y);\n    }\n  }]);\n\n  return TileSprite;\n}(src_GameObject);\n\n/* harmony default export */ const src_TileSprite = (TileSprite);\n;// CONCATENATED MODULE: ./src/Rect.js\nfunction Rect_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Rect_typeof = function _typeof(obj) { return typeof obj; }; } else { Rect_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Rect_typeof(obj); }\n\nfunction Rect_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Rect_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Rect_setPrototypeOf(subClass, superClass); }\n\nfunction Rect_setPrototypeOf(o, p) { Rect_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Rect_setPrototypeOf(o, p); }\n\nfunction Rect_createSuper(Derived) { var hasNativeReflectConstruct = Rect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Rect_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Rect_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Rect_possibleConstructorReturn(this, result); }; }\n\nfunction Rect_possibleConstructorReturn(self, call) { if (call && (Rect_typeof(call) === "object" || typeof call === "function")) { return call; } return Rect_assertThisInitialized(self); }\n\nfunction Rect_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Rect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Rect_getPrototypeOf(o) { Rect_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Rect_getPrototypeOf(o); }\n\n\n\n\nvar Rect = /*#__PURE__*/function (_GameObject) {\n  Rect_inherits(Rect, _GameObject);\n\n  var _super = Rect_createSuper(Rect);\n\n  function Rect() {\n    var _this;\n\n    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Graph.RECT;\n\n    Rect_classCallCheck(this, Rect);\n\n    _this = _super.call(this);\n    _this.type = type;\n    _this.w;\n    _this.h;\n    _this.style;\n    return _this;\n  }\n\n  return Rect;\n}(src_GameObject);\n\n/* harmony default export */ const src_Rect = (Rect);\n;// CONCATENATED MODULE: ./src/Renderer.js\nfunction Renderer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Renderer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Renderer_createClass(Constructor, protoProps, staticProps) { if (protoProps) Renderer_defineProperties(Constructor.prototype, protoProps); if (staticProps) Renderer_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar Render = /*#__PURE__*/function () {\n  function Render(config) {\n    Renderer_classCallCheck(this, Render);\n\n    var canvas = document.createElement("canvas");\n    this.view = canvas;\n    this.ctx = canvas.getContext("2d");\n    this.ctx.textBaseline = "top";\n    this.mode = config.mode;\n    this.w = this.view.width = config.w;\n    this.h = this.view.height = config.h;\n    this.pixel = config.pixel;\n    this.checkIsPixelConfig();\n\n    if (this.mode === Scale.RESIZE) {\n      var resizeCanvas = this.resizeCanvas.bind(this);\n      resizeCanvas();\n      window.addEventListener(\'resize\', resizeCanvas, false);\n    }\n  }\n\n  Renderer_createClass(Render, [{\n    key: "render",\n    value: function render(scene) {\n      var clear = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (scene.active == false) {\n        return;\n      }\n\n      var ctx = this.ctx,\n          w = this.w,\n          h = this.h,\n          mode = this.mode;\n\n      function renderRec(scene) {\n        var isFirstNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        // Render the container children\n        scene.children.forEach(function (child) {\n          if (child.visible == false) {\n            return;\n          }\n\n          ctx.save(); // Handle resize\n\n          if (mode === Scale.RESIZE && isFirstNode) {\n            ctx.translate(Math.round(scene.pos.x), Math.round(scene.pos.y)); // TO DO: Improve this\n\n            if (w > window.innerWidth && h < window.innerHeight) {\n              ctx.scale(window.innerWidth * 100 / w / 100, window.innerWidth * 100 / w / 100);\n            } else if (h > window.innerHeight && w < window.innerWidth) {\n              ctx.scale(window.innerHeight * 100 / h / 100, window.innerHeight * 100 / h / 100);\n            } else if (w > window.innerWidth && h > window.innerHeight) {\n              if (window.innerWidth > window.innerHeight) ctx.scale(window.innerHeight * 100 / h / 100, window.innerHeight * 100 / h / 100);else ctx.scale(window.innerWidth * 100 / w / 100, window.innerWidth * 100 / w / 100);\n            } else if (window.innerHeight > h) {\n              ctx.scale(window.innerHeight * 100 / h / 100, window.innerHeight * 100 / h / 100);\n            }\n          } // Handle transforms\n\n\n          if (child.pos) {\n            ctx.translate(Math.round(child.pos.x), Math.round(child.pos.y));\n          }\n\n          if (child.anchor) {\n            ctx.translate(child.anchor.x, child.anchor.y);\n          }\n\n          if (child.scale) {\n            ctx.scale(child.scale.x, child.scale.y);\n          }\n\n          if (child.rotation) {\n            var px = child.pivot ? child.pivot.x : 0;\n            var py = child.pivot ? child.pivot.y : 0;\n            ctx.translate(px, py);\n            ctx.rotate(child.rotation);\n            ctx.translate(-px, -py);\n          } // Draw the leaf nodes\n\n\n          if (child.text) {\n            var _child$style = child.style,\n                font = _child$style.font,\n                fill = _child$style.fill,\n                align = _child$style.align;\n            if (font) ctx.font = font;\n            if (fill) ctx.fillStyle = fill;\n            if (align) ctx.textAlign = align;\n            ctx.fillText(child.text, 0, 0);\n          } else if (child instanceof src_Sprite || child instanceof src_TileSprite) {\n            var img = child.texture;\n\n            if (child.frame) {\n              ctx.drawImage(img, child.frame.x * child.frame.w, child.frame.y * child.frame.h, child.frame.w, child.frame.h, 0, 0, child.frame.w, child.frame.h);\n            } else {\n              ctx.drawImage(img, 0, 0);\n            }\n          } else if (child instanceof src_Rect) {\n            if (child.type === Graph.RECT) {\n              var _fill = child.style.fill;\n              ctx.fillStyle = _fill;\n              ctx.fillRect(0, 0, child.w, child.h);\n            } else if (child.type === Graph.RECT_OUTLINE) {\n              var _child$style2 = child.style,\n                  _fill2 = _child$style2.fill,\n                  lineWidth = _child$style2.lineWidth;\n              ctx.strokeStyle = _fill2;\n              ctx.lineWidth = lineWidth;\n              ctx.strokeRect(0, 0, child.w, child.h);\n            }\n          } // Render any child sub-nodes\n\n\n          if (child.children) {\n            renderRec(child, false);\n          }\n\n          ctx.restore();\n        });\n      }\n\n      if (clear) {\n        ctx.clearRect(0, 0, w, h);\n      }\n\n      renderRec(scene);\n    }\n  }, {\n    key: "resizeCanvas",\n    value: function resizeCanvas() {\n      this.view.width = window.innerWidth;\n      this.view.height = window.innerHeight;\n      this.checkIsPixelConfig();\n    }\n  }, {\n    key: "checkIsPixelConfig",\n    value: function checkIsPixelConfig() {\n      if (this.pixel) {\n        this.view.style.imageRendering = \'pixelated\';\n        this.ctx.webkitImageSmoothingEnabled = false;\n        this.ctx.mozImageSmoothingEnabled = false;\n        this.ctx.imageSmoothingEnabled = false;\n      }\n    }\n  }]);\n\n  return Render;\n}();\n\n/* harmony default export */ const Renderer = (Render);\n;// CONCATENATED MODULE: ./src/Inputs.js\nfunction Inputs_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Inputs_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Inputs_createClass(Constructor, protoProps, staticProps) { if (protoProps) Inputs_defineProperties(Constructor.prototype, protoProps); if (staticProps) Inputs_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar KeyControls = /*#__PURE__*/function () {\n  function KeyControls() {\n    var _this = this;\n\n    Inputs_classCallCheck(this, KeyControls);\n\n    this.keys = {};\n    document.addEventListener("keydown", function (e) {\n      // Check is a trick to stop the browser scrolling if the game is embedded in a web page that has scrollbars\n      if ([37, 38, 39, 40, 32].indexOf(e.which) >= 0) {\n        e.preventDefault();\n      }\n\n      _this.keys[e.keyCode] = true;\n    }, false);\n    document.addEventListener("keyup", function (e) {\n      _this.keys[e.which] = false;\n    }, false);\n  }\n\n  Inputs_createClass(KeyControls, [{\n    key: "key",\n    value: function key(_key, value) {\n      if (value !== undefined) {\n        this.keys[_key] = value;\n      }\n\n      return this.keys[_key];\n    }\n  }, {\n    key: "reset",\n    value: function reset() {\n      for (var key in this.keys) {\n        this.keys[key] = false;\n      }\n    } // Handle key actions\n\n  }, {\n    key: "action",\n    get: function get() {\n      return this.keys[32];\n    }\n  }, {\n    key: "x",\n    get: function get() {\n      // left arrow or A key\n      if (this.keys[37] || this.keys[65]) {\n        return -1;\n      } // right arrow or D key\n\n\n      if (this.keys[39] || this.keys[68]) {\n        return 1;\n      }\n\n      return 0;\n    }\n  }, {\n    key: "y",\n    get: function get() {\n      // up arrow or W key\n      if (this.keys[38] || this.keys[87]) {\n        return -1;\n      } // down arrow or S key\n\n\n      if (this.keys[40] || this.keys[83]) {\n        return 1;\n      }\n\n      return 0;\n    }\n  }]);\n\n  return KeyControls;\n}();\n\nvar MouseControls = /*#__PURE__*/function () {\n  function MouseControls(container) {\n    var _this2 = this;\n\n    Inputs_classCallCheck(this, MouseControls);\n\n    this.el = container || document.body;\n    this.pos = {\n      x: 0,\n      y: 0\n    };\n    this.isDown = false;\n    this.pressed = false;\n    this.released = false; // Handlers\n\n    document.addEventListener("mousedown", function (e) {\n      return _this2.down(e);\n    }, false);\n    document.addEventListener("mouseup", function (e) {\n      return _this2.up(e);\n    }, false);\n    document.addEventListener("mousemove", function (e) {\n      return _this2.move(e);\n    }, false);\n  }\n\n  Inputs_createClass(MouseControls, [{\n    key: "mousePosFromEvent",\n    value: function mousePosFromEvent(_ref) {\n      var clientX = _ref.clientX,\n          clientY = _ref.clientY;\n      var el = this.el,\n          pos = this.pos;\n      var rect = el.getBoundingClientRect();\n      var xr = el.width / el.clientWidth;\n      var yr = el.height / el.clientHeight;\n      pos.x = (clientX - rect.left) * xr;\n      pos.y = (clientY - rect.top) * yr;\n    }\n  }, {\n    key: "down",\n    value: function down(e) {\n      this.isDown = true;\n      this.pressed = true;\n      this.mousePosFromEvent(e);\n    }\n  }, {\n    key: "up",\n    value: function up() {\n      this.isDown = false;\n      this.released = true;\n    }\n  }, {\n    key: "move",\n    value: function move(e) {\n      this.mousePosFromEvent(e);\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      this.released = false;\n      this.pressed = false;\n    }\n  }]);\n\n  return MouseControls;\n}();\n\n\n;// CONCATENATED MODULE: ./src/Text.js\nfunction Text_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Text_typeof = function _typeof(obj) { return typeof obj; }; } else { Text_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Text_typeof(obj); }\n\nfunction Text_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Text_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Text_setPrototypeOf(subClass, superClass); }\n\nfunction Text_setPrototypeOf(o, p) { Text_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Text_setPrototypeOf(o, p); }\n\nfunction Text_createSuper(Derived) { var hasNativeReflectConstruct = Text_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Text_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Text_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Text_possibleConstructorReturn(this, result); }; }\n\nfunction Text_possibleConstructorReturn(self, call) { if (call && (Text_typeof(call) === "object" || typeof call === "function")) { return call; } return Text_assertThisInitialized(self); }\n\nfunction Text_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Text_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Text_getPrototypeOf(o) { Text_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Text_getPrototypeOf(o); }\n\n\n\nvar Text = /*#__PURE__*/function (_GameObject) {\n  Text_inherits(Text, _GameObject);\n\n  var _super = Text_createSuper(Text);\n\n  function Text() {\n    var _this;\n\n    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";\n\n    Text_classCallCheck(this, Text);\n\n    _this = _super.call(this);\n    _this.text = text;\n    _this.style;\n    return _this;\n  }\n\n  return Text;\n}(src_GameObject);\n\n/* harmony default export */ const src_Text = (Text);\n;// CONCATENATED MODULE: ./src/Debug.js\nfunction Debug_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Debug_typeof = function _typeof(obj) { return typeof obj; }; } else { Debug_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Debug_typeof(obj); }\n\nfunction Debug_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Debug_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Debug_createClass(Constructor, protoProps, staticProps) { if (protoProps) Debug_defineProperties(Constructor.prototype, protoProps); if (staticProps) Debug_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Debug_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Debug_setPrototypeOf(subClass, superClass); }\n\nfunction Debug_setPrototypeOf(o, p) { Debug_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Debug_setPrototypeOf(o, p); }\n\nfunction Debug_createSuper(Derived) { var hasNativeReflectConstruct = Debug_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Debug_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Debug_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Debug_possibleConstructorReturn(this, result); }; }\n\nfunction Debug_possibleConstructorReturn(self, call) { if (call && (Debug_typeof(call) === "object" || typeof call === "function")) { return call; } return Debug_assertThisInitialized(self); }\n\nfunction Debug_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Debug_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Debug_getPrototypeOf(o) { Debug_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Debug_getPrototypeOf(o); }\n\n\n\n\n\n\nvar Debug = /*#__PURE__*/function (_Container) {\n  Debug_inherits(Debug, _Container);\n\n  var _super = Debug_createSuper(Debug);\n\n  function Debug() {\n    var _this;\n\n    Debug_classCallCheck(this, Debug);\n\n    _this = _super.call(this);\n    _this.active = false;\n    var fpsTxt = new src_Text(\'fps: \');\n    fpsTxt.name = \'fps\';\n    fpsTxt.pos = {\n      x: 5,\n      y: 15\n    };\n    fpsTxt.style = {\n      font: \'16px Arial\',\n      fill: \'red\',\n      align: \'left\'\n    };\n\n    _this.add(fpsTxt);\n\n    return _this;\n  } // addDebug(e) {\n  //     e.children = e.children || []\n  //     const i = new Rect(Graph.RECT_OUTLINE)\n  //     i.w = e.frame.w\n  //     i.h = e.frame.h\n  //     i.style = { fill: \'cyan\', lineWidth: 1 }\n  //     e.children.push(i)\n  //     if (e.hitBox) {\n  //         const { x, y, w, h } = e.hitBox;\n  //         const hb = new Rect(Graph.RECT_OUTLINE)\n  //         hb.style = { fill: \'rgba(255, 0, 0, 0.5)\' }\n  //         hb.name = "hb"\n  //         hb.w = w\n  //         hb.h = h\n  //         hb.pos = { x, y }\n  //         e.children.push(hb);\n  //     }\n  // }\n\n\n  Debug_createClass(Debug, [{\n    key: "addDebug",\n    value: function addDebug(e) {\n      e.children = e.children || [];\n      var i = new src_Rect(Graph.RECT_OUTLINE);\n      i.w = e.frame.w;\n      i.h = e.frame.h;\n      i.style = {\n        fill: \'cyan\',\n        lineWidth: 1\n      };\n      e.children.push(i);\n\n      if (e.body) {\n        var _e$body = e.body,\n            x = _e$body.x,\n            y = _e$body.y,\n            w = _e$body.w,\n            h = _e$body.h;\n        var hb = new src_Rect(Graph.RECT_OUTLINE);\n        hb.style = {\n          fill: \'rgba(255, 0, 0, 1)\'\n        };\n        hb.name = "hb";\n        hb.w = w;\n        hb.h = h;\n        hb.pos = {\n          x: x,\n          y: y\n        };\n        e.children.push(hb);\n      }\n    }\n  }]);\n\n  return Debug;\n}(src_Container);\n\n/* harmony default export */ const src_Debug = (Debug);\n;// CONCATENATED MODULE: ./src/Game.js\nfunction Game_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Game_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Game_createClass(Constructor, protoProps, staticProps) { if (protoProps) Game_defineProperties(Constructor.prototype, protoProps); if (staticProps) Game_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Game_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nvar Game = /*#__PURE__*/function () {\n  function Game(config) {\n    Game_classCallCheck(this, Game);\n\n    Game_defineProperty(this, "step", 1 / 60);\n\n    Game_defineProperty(this, "MAX_FRAME", this.step * 5);\n\n    this.w = config.w;\n    this.h = config.h;\n    this.renderer = this.createRenderer(config);\n    this.scenes = [];\n    this.scene;\n    this.textures;\n    this.controls = new KeyControls();\n    this.mouse = new MouseControls(this.renderer.view);\n    this.debug = new src_Debug();\n    this.debug.active = config.debugMode;\n  }\n\n  Game_createClass(Game, [{\n    key: "addScene",\n    value: function addScene(scene) {\n      if (this.debug.active) scene.add(this.debug);\n      if (!this.scene) this.scene = scene;\n      this.scenes.push(scene);\n    }\n  }, {\n    key: "launchScene",\n    value: function launchScene(sceneName) {\n      this.scene = this.scenes.find(function (s) {\n        return s.key === sceneName;\n      });\n      this.scene.init();\n    }\n  }, {\n    key: "run",\n    value: function run() {\n      var _this = this;\n\n      var gameUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      var MAX_FRAME = this.MAX_FRAME;\n      var dt = 0;\n      var last = 0;\n      var fps = 0;\n\n      var mainloop = function mainloop(ms) {\n        requestAnimationFrame(mainloop); // create delta\n\n        var t = ms / 1000;\n        dt = Math.min(t - last, MAX_FRAME);\n        last = t;\n        fps = Math.round(1 / dt);\n        if (!_this.scene && _this.debug.active) return;\n        if (_this.debug.active) _this.scene.children.find(function (child) {\n          return child instanceof src_Debug;\n        }).children.find(function (c) {\n          return c.name === "fps";\n        }).text = \'fps-: \' + fps;\n\n        _this.scene.update(dt, t);\n\n        gameUpdate(dt, t, _this.controls);\n\n        _this.renderer.render(_this.scene);\n      };\n\n      requestAnimationFrame(mainloop);\n    }\n  }, {\n    key: "createRenderer",\n    value: function createRenderer(config) {\n      var renderer = new Renderer(config);\n      var parent = config.parent || "game";\n      var el = document.querySelector(config.parent);\n\n      if (!el) {\n        document.body.innerHTML = \'<div id="\' + parent + \'"></div>\';\n      }\n\n      document.getElementById(parent).appendChild(renderer.view);\n      return renderer;\n    }\n  }]);\n\n  return Game;\n}();\n\n/* harmony default export */ const src_Game = (Game);\n;// CONCATENATED MODULE: ./src/TextureManager.js\nfunction TextureManager_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction TextureManager_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextureManager_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextureManager_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextureManager_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextureManager_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar TextureManager = /*#__PURE__*/function () {\n  function TextureManager(urls) {\n    TextureManager_classCallCheck(this, TextureManager);\n\n    this.urls = urls;\n    this.imgs = {};\n  }\n\n  TextureManager_createClass(TextureManager, [{\n    key: "load",\n    value: function load(callback) {\n      var _this = this;\n\n      var p = this.urls.map(function (i) {\n        return _this.loadImage(i);\n      });\n      Promise.all(p).then(function (res) {\n        var o = _this.imgs = Object.assign.apply(Object, _toConsumableArray(res));\n        return callback(null, o);\n      })["catch"](function (err) {\n        return callback(err);\n      });\n    }\n  }, {\n    key: "loadImage",\n    value: function loadImage(i) {\n      return new Promise(function (resolve, reject) {\n        var img = new Image();\n        img.addEventListener(\'load\', function () {\n          var o = TextureManager_defineProperty({}, i[0], img);\n\n          resolve(o);\n        });\n        img.addEventListener(\'error\', function () {\n          console.error(\'Error when loading an image\');\n          reject();\n        });\n        img.src = i[1];\n      });\n    }\n  }]);\n\n  return TextureManager;\n}();\n\n/* harmony default export */ const src_TextureManager = (TextureManager);\n;// CONCATENATED MODULE: ./src/TileMap.js\nfunction TileMap_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { TileMap_typeof = function _typeof(obj) { return typeof obj; }; } else { TileMap_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return TileMap_typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || TileMap_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TileMap_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TileMap_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TileMap_arrayLikeToArray(o, minLen); }\n\nfunction TileMap_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction TileMap_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction TileMap_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { TileMap_ownKeys(Object(source), true).forEach(function (key) { TileMap_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { TileMap_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction TileMap_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TileMap_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TileMap_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TileMap_createClass(Constructor, protoProps, staticProps) { if (protoProps) TileMap_defineProperties(Constructor.prototype, protoProps); if (staticProps) TileMap_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction TileMap_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) TileMap_setPrototypeOf(subClass, superClass); }\n\nfunction TileMap_setPrototypeOf(o, p) { TileMap_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TileMap_setPrototypeOf(o, p); }\n\nfunction TileMap_createSuper(Derived) { var hasNativeReflectConstruct = TileMap_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TileMap_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TileMap_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TileMap_possibleConstructorReturn(this, result); }; }\n\nfunction TileMap_possibleConstructorReturn(self, call) { if (call && (TileMap_typeof(call) === "object" || typeof call === "function")) { return call; } return TileMap_assertThisInitialized(self); }\n\nfunction TileMap_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TileMap_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TileMap_getPrototypeOf(o) { TileMap_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TileMap_getPrototypeOf(o); }\n\n\n\n\nvar TileMap = /*#__PURE__*/function (_Container) {\n  TileMap_inherits(TileMap, _Container);\n\n  var _super = TileMap_createSuper(TileMap);\n\n  function TileMap() {\n    var _this;\n\n    var texture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    TileMap_classCallCheck(this, TileMap);\n\n    _this = _super.call(this);\n    _this.mapW;\n    _this.mapH;\n    _this.tileW;\n    _this.tileH;\n    _this.texture = texture;\n    _this.children = [];\n    return _this;\n  }\n\n  TileMap_createClass(TileMap, [{\n    key: "addTiles",\n    value: function addTiles(tiles) {\n      var _this2 = this;\n\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      // Add all tile sprites\n      this.children = tiles.map(function (frame, i) {\n        var s = new src_TileSprite(_this2.texture);\n        s.frame = TileMap_objectSpread(TileMap_objectSpread({}, frame), {}, {\n          w: _this2.tileW,\n          h: _this2.tileH\n        });\n        s.scale = {\n          x: scale,\n          y: scale\n        };\n        s.pos.x = i % _this2.mapW * _this2.tileW;\n        s.pos.y = Math.floor(i / _this2.mapW) * _this2.tileH;\n        return s;\n      });\n    }\n  }, {\n    key: "pixelToMapPos",\n    value: function pixelToMapPos(pos) {\n      var tileW = this.tileW,\n          tileH = this.tileH;\n      return {\n        x: Math.floor(pos.x / tileW),\n        y: Math.floor(pos.y / tileH)\n      };\n    }\n  }, {\n    key: "mapToPixelPos",\n    value: function mapToPixelPos(mapPos) {\n      var tileW = this.tileW,\n          tileH = this.tileH;\n      return {\n        x: mapPos.x * tileW,\n        y: mapPos.y * tileH\n      };\n    }\n  }, {\n    key: "tileAtMapPos",\n    value: function tileAtMapPos(mapPos) {\n      return this.children[mapPos.y * this.mapW + mapPos.x];\n    }\n  }, {\n    key: "tileAtPixelPos",\n    value: function tileAtPixelPos(pos) {\n      return this.tileAtMapPos(this.pixelToMapPos(pos));\n    }\n  }, {\n    key: "setFrameAtMapPos",\n    value: function setFrameAtMapPos(mapPos, frame) {\n      var tile = this.tileAtMapPos(mapPos);\n      tile.frame = frame;\n      return tile;\n    }\n  }, {\n    key: "setFrameAtPixelPos",\n    value: function setFrameAtPixelPos(pos, frame) {\n      return this.setFrameAtMapPos(this.pixelToMapPos(pos), frame);\n    }\n  }, {\n    key: "tilesAtCorners",\n    value: function tilesAtCorners(bounds) {\n      var _this3 = this;\n\n      var xo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var yo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      return [[bounds.x, bounds.y], // Top-left\n      [bounds.x + bounds.w, bounds.y], // Top-right\n      [bounds.x, bounds.y + bounds.h], // Bottom-left\n      [bounds.x + bounds.w, bounds.y + bounds.h] // Bottom-right\n      ].map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            x = _ref2[0],\n            y = _ref2[1];\n\n        return _this3.tileAtPixelPos({\n          x: x + xo,\n          y: y + yo\n        });\n      });\n    }\n  }]);\n\n  return TileMap;\n}(src_Container);\n\n/* harmony default export */ const src_TileMap = (TileMap);\n;// CONCATENATED MODULE: ./src/Camera.js\nfunction Camera_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Camera_typeof = function _typeof(obj) { return typeof obj; }; } else { Camera_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Camera_typeof(obj); }\n\nfunction Camera_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Camera_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Camera_createClass(Constructor, protoProps, staticProps) { if (protoProps) Camera_defineProperties(Constructor.prototype, protoProps); if (staticProps) Camera_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Camera_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Camera_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Camera_setPrototypeOf(subClass, superClass); }\n\nfunction Camera_setPrototypeOf(o, p) { Camera_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Camera_setPrototypeOf(o, p); }\n\nfunction Camera_createSuper(Derived) { var hasNativeReflectConstruct = Camera_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Camera_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Camera_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Camera_possibleConstructorReturn(this, result); }; }\n\nfunction Camera_possibleConstructorReturn(self, call) { if (call && (Camera_typeof(call) === "object" || typeof call === "function")) { return call; } return Camera_assertThisInitialized(self); }\n\nfunction Camera_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Camera_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Camera_getPrototypeOf(o) { Camera_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Camera_getPrototypeOf(o); }\n\n\n\n\nvar Camera = /*#__PURE__*/function (_Container) {\n  Camera_inherits(Camera, _Container);\n\n  var _super = Camera_createSuper(Camera);\n\n  function Camera(subject, viewport) {\n    var _this;\n\n    var worldSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : viewport;\n\n    Camera_classCallCheck(this, Camera);\n\n    _this = _super.call(this);\n    _this.w = viewport.w;\n    _this.h = viewport.h;\n    _this.worldSize = worldSize;\n\n    _this.setSubject(subject);\n\n    return _this;\n  }\n\n  Camera_createClass(Camera, [{\n    key: "setSubject",\n    value: function setSubject(e) {\n      this.subject = e ? e.pos || e : this.pos;\n      this.offset = {\n        x: 0,\n        y: 0\n      }; // Center on the entity\n\n      if (e && e.frame.w) {\n        this.offset.x += e.frame.w / 2;\n        this.offset.y += e.frame.h / 2;\n      }\n\n      if (e && e.anchor) {\n        this.offset.x -= e.anchor.x;\n        this.offset.y -= e.anchor.y;\n      }\n\n      this.focus();\n    }\n  }, {\n    key: "focus",\n    value: function focus() {\n      var pos = this.pos,\n          w = this.w,\n          h = this.h,\n          worldSize = this.worldSize,\n          subject = this.subject,\n          offset = this.offset;\n      var centeredX = subject.x + offset.x - w / 2;\n      var maxX = worldSize.w - w;\n      var x = -utils.clamp(centeredX, 0, maxX);\n      var centeredY = subject.y + offset.y - h / 2;\n      var maxY = worldSize.h - h;\n      var y = -utils.clamp(centeredY, 0, maxY);\n      pos.x = x;\n      pos.y = y;\n    }\n  }, {\n    key: "update",\n    value: function update(dt, t) {\n      _get(Camera_getPrototypeOf(Camera.prototype), "update", this).call(this, dt, t);\n\n      if (this.subject) {\n        this.focus();\n      }\n    }\n  }]);\n\n  return Camera;\n}(src_Container);\n\n/* harmony default export */ const src_Camera = (Camera);\n;// CONCATENATED MODULE: ./src/wallslide.js\nfunction wallslide_slicedToArray(arr, i) { return wallslide_arrayWithHoles(arr) || wallslide_iterableToArrayLimit(arr, i) || wallslide_unsupportedIterableToArray(arr, i) || wallslide_nonIterableRest(); }\n\nfunction wallslide_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction wallslide_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return wallslide_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return wallslide_arrayLikeToArray(o, minLen); }\n\nfunction wallslide_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction wallslide_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction wallslide_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction wallslide(ent, map) {\n  var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var tiles;\n  var tileEdge;\n  var hitBox = ent.hitBox,\n      pos = ent.pos;\n  var hit = hitBox;\n  var bounds = {\n    x: hit.x + pos.x,\n    y: hit.y + pos.y,\n    w: hit.w,\n    h: hit.h\n  }; // Final amounts of movement to allow\n\n  var xo = x;\n  var yo = y; // Check vertical movement\n\n  if (y !== 0) {\n    tiles = map.tilesAtCorners(bounds, 0, yo);\n\n    var _tiles$map = tiles.map(function (t) {\n      return t && t.frame.rigid;\n    }),\n        _tiles$map2 = wallslide_slicedToArray(_tiles$map, 4),\n        tl = _tiles$map2[0],\n        tr = _tiles$map2[1],\n        bl = _tiles$map2[2],\n        br = _tiles$map2[3]; // Hit your head\n\n\n    if (y < 0 && !(tl && tr)) {\n      tileEdge = tiles[0].pos.y + tiles[0].frame.h;\n      yo = tileEdge - bounds.y + 1;\n    } // Hit your feet\n\n\n    if (y > 0 && !(bl && br)) {\n      tileEdge = tiles[2].pos.y - 1;\n      yo = tileEdge - (bounds.y + bounds.h);\n    }\n  } // Check horizontal movement\n\n\n  if (x !== 0) {\n    tiles = map.tilesAtCorners(bounds, xo, yo);\n\n    var _tiles$map3 = tiles.map(function (t) {\n      return t && t.frame.rigid;\n    }),\n        _tiles$map4 = wallslide_slicedToArray(_tiles$map3, 4),\n        _tl = _tiles$map4[0],\n        _tr = _tiles$map4[1],\n        _bl = _tiles$map4[2],\n        _br = _tiles$map4[3]; // Hit left edge\n\n\n    if (x < 0 && !(_tl && _bl)) {\n      tileEdge = tiles[0].pos.x + tiles[0].frame.w;\n      xo = tileEdge - bounds.x + 1;\n    } // Hit right edge\n\n\n    if (x > 0 && !(_tr && _br)) {\n      tileEdge = tiles[1].pos.x - 1;\n      xo = tileEdge - (bounds.x + bounds.w);\n    }\n  } // xo & yo contain the amount we\'re allowed to move by.\n\n\n  return {\n    x: xo,\n    y: yo\n  };\n}\n\n/* harmony default export */ const src_wallslide = (wallslide);\n;// CONCATENATED MODULE: ./src/vx-one.js\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdngvLi9zcmMvQ29udGFpbmVyLmpzP2FlNmUiLCJ3ZWJwYWNrOi8vdngvLi9zcmMvQ29uc3RhbnRzLmpzP2UzNjciLCJ3ZWJwYWNrOi8vdngvLi9zcmMvU2NlbmUuanM/MWEwZSIsIndlYnBhY2s6Ly92eC8uL3NyYy9HYW1lT2JqZWN0LmpzP2FmZDMiLCJ3ZWJwYWNrOi8vdngvLi9zcmMvQW5pbU1hbmFnZXIuanM/ZmQwMiIsIndlYnBhY2s6Ly92eC8uL3NyYy91dGlscy5qcz8wMjVlIiwid2VicGFjazovL3Z4Ly4vc3JjL1Nwcml0ZS5qcz83NDA3Iiwid2VicGFjazovL3Z4Ly4vc3JjL1RpbGVTcHJpdGUuanM/ZjhmOSIsIndlYnBhY2s6Ly92eC8uL3NyYy9SZWN0LmpzPzc0YjEiLCJ3ZWJwYWNrOi8vdngvLi9zcmMvUmVuZGVyZXIuanM/ZThjOCIsIndlYnBhY2s6Ly92eC8uL3NyYy9JbnB1dHMuanM/ZjYxYSIsIndlYnBhY2s6Ly92eC8uL3NyYy9UZXh0LmpzPzkyNTYiLCJ3ZWJwYWNrOi8vdngvLi9zcmMvRGVidWcuanM/ZjVjYiIsIndlYnBhY2s6Ly92eC8uL3NyYy9HYW1lLmpzPzg0MDQiLCJ3ZWJwYWNrOi8vdngvLi9zcmMvVGV4dHVyZU1hbmFnZXIuanM/MGY1ZCIsIndlYnBhY2s6Ly92eC8uL3NyYy9UaWxlTWFwLmpzPzdiZTYiLCJ3ZWJwYWNrOi8vdngvLi9zcmMvQ2FtZXJhLmpzP2MyMjEiLCJ3ZWJwYWNrOi8vdngvLi9zcmMvd2FsbHNsaWRlLmpzP2E4NTciLCJ3ZWJwYWNrOi8vdngvLi9zcmMvdngtb25lLmpzP2E4OTYiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgQ29udGFpbmVyIHtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnBvcyA9IHsgeDogMCwgeTogMCB9XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW11cclxuICB9XHJcblxyXG4gIHVwZGF0ZShkdCwgdCkge1xyXG4gICAgdGhpcy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+IHtcclxuICAgICAgaWYgKGNoaWxkLnVwZGF0ZSkge1xyXG4gICAgICAgIGNoaWxkLnVwZGF0ZShkdCwgdCwgdGhpcylcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY2hpbGQuZGVhZCA/IGZhbHNlIDogdHJ1ZVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGFkZChjaGlsZCkge1xyXG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKVxyXG4gICAgcmV0dXJuIGNoaWxkXHJcbiAgfVxyXG5cclxuICByZW1vdmUoY2hpbGQpIHtcclxuICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmZpbHRlcihjID0+IGMgIT09IGNoaWxkKVxyXG4gICAgcmV0dXJuIGNoaWxkXHJcbiAgfVxyXG5cclxuICBtYXAoZikge1xyXG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubWFwKGYpXHJcbiAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29udGFpbmVyXHJcbiIsImNvbnN0IFNjYWxlID0ge1xyXG4gICAgTk9ORTogMCxcclxuICAgIFJFU0laRTogMVxyXG59XHJcblxyXG5jb25zdCBTdGF0ZSA9IHtcclxuICAgIE5PTkU6IDAsXHJcbiAgICBMT0FESU5HOiAxLFxyXG4gICAgUkVBRFk6IDIsXHJcbiAgICBSVU5OSU5HOiAzLFxyXG4gICAgU0xFRVBJTkc6IDRcclxufVxyXG5cclxuY29uc3QgR3JhcGggPSB7XHJcbiAgICBSRUNUOiAwLFxyXG4gICAgUkVDVF9PVVRMSU5FOiAxXHJcbn1cclxuXHJcbmV4cG9ydCB7XHJcbiAgICBTY2FsZSxcclxuICAgIFN0YXRlLFxyXG4gICAgR3JhcGhcclxufSIsImltcG9ydCBDb250YWluZXIgZnJvbSBcIi4vQ29udGFpbmVyLmpzXCJcclxuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICcuL0NvbnN0YW50cy5qcydcclxuXHJcbmNsYXNzIFNjZW5lIGV4dGVuZHMgQ29udGFpbmVyIHtcclxuICBjb25zdHJ1Y3RvcihrZXksIGlzQWN0aXZlID0gZmFsc2UpIHtcclxuICAgIHN1cGVyKClcclxuICAgIHRoaXMua2V5ID0ga2V5XHJcbiAgICB0aGlzLmFjdGl2ZSA9IGlzQWN0aXZlXHJcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuTk9ORVxyXG4gICAgdGhpcy5jb250cm9sc1xyXG4gIH1cclxuXHJcbiAgZ2V0Qm91bmRzKGVudGl0eSkge1xyXG4gICAgY29uc3QgeyBoaXRCb3gsIHBvcyB9ID0gZW50aXR5XHJcbiAgICBjb25zdCBoaXQgPSBoaXRCb3hcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogaGl0LnggKyBwb3MueCxcclxuICAgICAgeTogaGl0LnkgKyBwb3MueSxcclxuICAgICAgdzogaGl0LncgLSAxLFxyXG4gICAgICBoOiBoaXQuaCAtIDFcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlzT3ZlbGFwcGluZyhlMSwgZTIpIHtcclxuICAgIGNvbnN0IGEgPSB0aGlzLmdldEJvdW5kcyhlMSlcclxuICAgIGNvbnN0IGIgPSB0aGlzLmdldEJvdW5kcyhlMilcclxuICAgIHJldHVybiAoXHJcbiAgICAgIGEueCA8PSBiLnggKyBiLncgJiZcclxuICAgICAgYS54ICsgYS53ID49IGIueCAmJlxyXG4gICAgICBhLnkgPD0gYi55ICsgYi5oICYmXHJcbiAgICAgIGEueSArIGEuaCA+PSBiLnlcclxuICAgIClcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNjZW5lIiwiY2xhc3MgR2FtZU9iamVjdCB7XHJcbiAgY29uc3RydWN0b3IobmFtZSA9IG51bGwpIHtcclxuICAgIHRoaXMubmFtZSA9IG5hbWVcclxuICAgIHRoaXMucG9zID0geyB4OiAwLCB5OiAwIH1cclxuICAgIHRoaXMuc2NhbGUgPSB7IHg6IDEsIHk6IDEgfVxyXG4gICAgdGhpcy5hbmNob3IgPSB7IHg6IDAsIHk6IDAgfVxyXG4gICAgdGhpcy5waXZvdCA9IHsgeDogMCwgeTogMCB9XHJcbiAgICB0aGlzLnJvdGF0aW9uID0gMFxyXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZVxyXG4gICAgdGhpcy56SW5kZXggPSAxXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHYW1lT2JqZWN0IiwiY2xhc3MgQW5pbSB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGZyYW1lcywgcmF0ZSkge1xyXG4gICAgdGhpcy5mcmFtZXMgPSBmcmFtZXNcclxuICAgIHRoaXMucmF0ZSA9IHJhdGVcclxuICAgIHRoaXMucmVzZXQoKVxyXG4gIH1cclxuXHJcbiAgcmVzZXQoKSB7XHJcbiAgICB0aGlzLmZyYW1lID0gdGhpcy5mcmFtZXNbMF07XHJcbiAgICB0aGlzLmN1ckZyYW1lID0gMFxyXG4gICAgdGhpcy5jdXJUaW1lID0gMFxyXG4gIH1cclxuXHJcbiAgdXBkYXRlKGR0KSB7XHJcbiAgICBjb25zdCB7IHJhdGUsIGZyYW1lcyB9ID0gdGhpcztcclxuICAgIGlmICgodGhpcy5jdXJUaW1lICs9IGR0KSA+IHJhdGUpIHtcclxuICAgICAgdGhpcy5jdXJGcmFtZSsrXHJcbiAgICAgIHRoaXMuZnJhbWUgPSBmcmFtZXNbdGhpcy5jdXJGcmFtZSAlIGZyYW1lcy5sZW5ndGhdXHJcbiAgICAgIHRoaXMuY3VyVGltZSAtPSByYXRlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxufVxyXG5cclxuY2xhc3MgQW5pbU1hbmFnZXIge1xyXG4gIGNvbnN0cnVjdG9yKGUgPSB7IHg6IDAsIHk6IDAgfSkge1xyXG4gICAgdGhpcy5hbmltcyA9IHt9XHJcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZVxyXG4gICAgdGhpcy5mcmFtZVNvdXJjZSA9IGUuZnJhbWUgfHwgZVxyXG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbFxyXG4gIH1cclxuXHJcbiAgYWRkKG5hbWUsIGZyYW1lcywgc3BlZWQpIHtcclxuICAgIHRoaXMuYW5pbXNbbmFtZV0gPSBuZXcgQW5pbShmcmFtZXMsIHNwZWVkKVxyXG4gICAgcmV0dXJuIHRoaXMuYW5pbXNbbmFtZV1cclxuICB9XHJcblxyXG4gIHVwZGF0ZShkdCkge1xyXG4gICAgY29uc3QgeyBjdXJyZW50LCBhbmltcywgZnJhbWVTb3VyY2UgfSA9IHRoaXM7XHJcbiAgICBpZiAoIWN1cnJlbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYW5pbSA9IGFuaW1zW2N1cnJlbnRdO1xyXG4gICAgYW5pbS51cGRhdGUoZHQpO1xyXG5cclxuICAgIC8vIFN5bmMgdGhlIHRpbGVTcHJpdGUgZnJhbWVcclxuICAgIGZyYW1lU291cmNlLnggPSBhbmltLmZyYW1lLng7XHJcbiAgICBmcmFtZVNvdXJjZS55ID0gYW5pbS5mcmFtZS55O1xyXG4gIH1cclxuXHJcbiAgcGxheShhbmltKSB7XHJcbiAgICBjb25zdCB7IGN1cnJlbnQsIGFuaW1zIH0gPSB0aGlzO1xyXG4gICAgaWYgKGFuaW0gPT09IGN1cnJlbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jdXJyZW50ID0gYW5pbTtcclxuICAgIGFuaW1zW2FuaW1dLnJlc2V0KCk7XHJcbiAgfVxyXG5cclxuICBzdG9wKCkge1xyXG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFuaW1NYW5hZ2VyO1xyXG4iLCJmdW5jdGlvbiByYW5kZihtaW4sIG1heCkge1xyXG4gICAgaWYgKG1heCA9PSBudWxsKSB7XHJcbiAgICAgICAgbWF4ID0gbWluIHx8IDE7XHJcbiAgICAgICAgbWluID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJhbmQobWluLCBtYXgpIHtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKHJhbmRmKG1pbiwgbWF4KSlcclxufVxyXG5mdW5jdGlvbiBjbGFtcCh4LCBtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4oeCwgbWF4KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJhbmRPbmVGcm9tKGl0ZW1zKSB7XHJcbiAgICByZXR1cm4gaXRlbXNbcmFuZChpdGVtcy5sZW5ndGgpXTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmFuZE9uZUluKG1heCA9IDIpIHtcclxuICAgIHJldHVybiByYW5kKDAsIG1heCkgPT09IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZsaXBBbmNob3IoZmxpcHBlZCwgZnJhbWUsIHNjYWxlLCBvcmlnaW4pIHtcclxuICAgIGxldCBhbmNob3JcclxuICAgIGlmIChmbGlwcGVkKSB7XHJcbiAgICAgICAgaWYgKG9yaWdpbi54ID09PSAwKVxyXG4gICAgICAgICAgICBhbmNob3IgPSBmcmFtZS53ICogTWF0aC5hYnMoc2NhbGUueClcclxuICAgICAgICBlbHNlIGlmIChvcmlnaW4ueCA9PT0gMSlcclxuICAgICAgICAgICAgYW5jaG9yID0gMFxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKG9yaWdpbi54ID09PSAwKVxyXG4gICAgICAgICAgICBhbmNob3IgPSAwXHJcbiAgICAgICAgZWxzZSBpZiAob3JpZ2luLnggPT09IDEpXHJcbiAgICAgICAgICAgIGFuY2hvciA9IC0oZnJhbWUudyAqIE1hdGguYWJzKHNjYWxlLngpKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFuY2hvclxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICByYW5kLFxyXG4gICAgcmFuZGYsXHJcbiAgICBjbGFtcCxcclxuICAgIHJhbmRPbmVGcm9tLFxyXG4gICAgcmFuZE9uZUluLFxyXG59XHJcblxyXG5leHBvcnQge1xyXG4gICAgZmxpcEFuY2hvclxyXG59IiwiaW1wb3J0IEdhbWVPYmplY3QgZnJvbSBcIi4vR2FtZU9iamVjdC5qc1wiXHJcbmltcG9ydCBBbmltTWFuYWdlciBmcm9tIFwiLi9BbmltTWFuYWdlci5qc1wiXHJcbmltcG9ydCB7IGZsaXBBbmNob3IgfSBmcm9tICcuL3V0aWxzLmpzJ1xyXG5cclxuY2xhc3MgU3ByaXRlIGV4dGVuZHMgR2FtZU9iamVjdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0dXJlID0gbnVsbCwgaGFzQW5pbSA9IHRydWUpIHtcclxuICAgICAgICBzdXBlcigpXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZVxyXG4gICAgICAgIHRoaXMuZmxpcHBlZCA9IHsgeDogZmFsc2UsIHk6IGZhbHNlIH1cclxuICAgICAgICB0aGlzLmJvZHkgPSB7fVxyXG4gICAgICAgIHRoaXMub3JpZ2luID0geyB4OiAwLCB5OiAwIH1cclxuICAgICAgICBpZiAoaGFzQW5pbSkge1xyXG4gICAgICAgICAgICB0aGlzLmZyYW1lID0geyB4OiAwLCB5OiAwLCB3OiB0ZXh0dXJlLndpZHRoLCBoOiB0ZXh0dXJlLmhlaWdodCB9XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbXMgPSBuZXcgQW5pbU1hbmFnZXIodGhpcylcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGhpdEJveCh7IHgsIHksIHcsIGggfSkge1xyXG4gICAgICAgIHRoaXMuYm9keSA9IHsgeCwgeSwgdywgaCB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGhpdEJveCgpIHtcclxuICAgICAgICBjb25zdCB7IGFuY2hvciwgYm9keSwgc2NhbGUsIGZyYW1lLCBmbGlwcGVkLCBvcmlnaW4gfSA9IHRoaXNcclxuICAgICAgICBsZXQgeCwgeVxyXG4gICAgICAgIHggPSBNYXRoLmFicyhib2R5LnggKiBzY2FsZS54KVxyXG4gICAgICAgIHkgPSBNYXRoLmFicyhib2R5LnkgKiBzY2FsZS55KVxyXG4gICAgICAgIGxldCBhbmNob3JYID0gYW5jaG9yLnhcclxuXHJcbiAgICAgICAgaWYgKG9yaWdpbi54ID09PSAwIHx8IG9yaWdpbi54ID09PSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlQ2xvbmUgPSB7IC4uLnNjYWxlLCB4OiBNYXRoLmFicyhzY2FsZS54KSB9XHJcbiAgICAgICAgICAgIGFuY2hvclggPSBmbGlwQW5jaG9yKGZhbHNlLCBmcmFtZSwgc2NhbGVDbG9uZSwgb3JpZ2luKVxyXG4gICAgICAgICAgICB4ID0geCArIGFuY2hvclhcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoYW5jaG9yWCAhPT0gMClcclxuICAgICAgICAgICAgICAgIHggPSB4ICsgYW5jaG9yWCAqIChmbGlwcGVkLnggPyAtMSA6IDEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYW5jaG9yLnkgIT09IDApXHJcbiAgICAgICAgICAgIHkgPSB5ICsgYW5jaG9yLnlcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgdzogTWF0aC5hYnMoYm9keS53ICogc2NhbGUueCksXHJcbiAgICAgICAgICAgIGg6IE1hdGguYWJzKGJvZHkuaCAqIHNjYWxlLnkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldE9yaWdpbih4LCB5KSB7XHJcbiAgICAgICAgY29uc3QgeyBhbmNob3IsIGZyYW1lIH0gPSB0aGlzXHJcbiAgICAgICAgY29uc3QgX3kgPSB5IHx8IHhcclxuICAgICAgICBhbmNob3IueCA9IC0oZnJhbWUudyAqIHgpXHJcbiAgICAgICAgYW5jaG9yLnkgPSAtKGZyYW1lLmggKiBfeSlcclxuICAgICAgICB0aGlzLm9yaWdpbiA9IHsgeDogeCwgeTogX3kgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldFNjYWxlKHgsIHkpIHtcclxuICAgICAgICBjb25zdCB7IHNjYWxlLCBhbmNob3IgfSA9IHRoaXNcclxuICAgICAgICBjb25zdCBfeSA9IHkgfHwgeFxyXG4gICAgICAgIHNjYWxlLnggPSBNYXRoLmFicyh4KVxyXG4gICAgICAgIHNjYWxlLnkgPSBNYXRoLmFicyhfeSlcclxuICAgICAgICAvL2ZpeCBhbmNob3IgICAgICAgIFxyXG4gICAgICAgIGFuY2hvci54ID0gYW5jaG9yLnggKiBzY2FsZS54XHJcbiAgICAgICAgYW5jaG9yLnkgPSBhbmNob3IueSAqIHNjYWxlLnlcclxuICAgIH1cclxuXHJcbiAgICBmbGlwKGZ4LCBmeSA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgeyBzY2FsZSwgYW5jaG9yLCBmcmFtZSwgb3JpZ2luIH0gPSB0aGlzXHJcbiAgICAgICAgdGhpcy5mbGlwcGVkLnggPSBmeFxyXG4gICAgICAgIHRoaXMuZmxpcHBlZC55ID0gZnlcclxuXHJcbiAgICAgICAgY29uc3QgZnhObyA9IGZ4ID8gLTEgOiAxXHJcblxyXG4gICAgICAgIGlmIChmeCkge1xyXG4gICAgICAgICAgICBzY2FsZS54ID0gZnhObyAqIE1hdGguYWJzKHNjYWxlLngpXHJcbiAgICAgICAgICAgIGlmIChvcmlnaW4ueCA9PT0gMCB8fCBvcmlnaW4ueCA9PT0gMSlcclxuICAgICAgICAgICAgICAgIGFuY2hvci54ID0gZmxpcEFuY2hvcih0cnVlLCBmcmFtZSwgc2NhbGUsIG9yaWdpbilcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNjYWxlLnggPSBmeE5vICogTWF0aC5hYnMoc2NhbGUueClcclxuICAgICAgICAgICAgaWYgKG9yaWdpbi54ID09PSAwIHx8IG9yaWdpbi54ID09PSAxKVxyXG4gICAgICAgICAgICAgICAgYW5jaG9yLnggPSBmbGlwQW5jaG9yKGZhbHNlLCBmcmFtZSwgc2NhbGUsIG9yaWdpbilcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9yaWdpbi54ID4gMCAmJiBvcmlnaW4ueCA8IDEpXHJcbiAgICAgICAgICAgIGFuY2hvci54ID0gc2NhbGUueCA+IDAgPyAtTWF0aC5hYnMoYW5jaG9yLngpIDogTWF0aC5hYnMoYW5jaG9yLngpXHJcblxyXG4gICAgICAgIC8vIEl0IG5lZWRzIHRvIGJlIGltcHJvdmVkLCBqdXN0IHdvcmtzIHRvIGZsaXAgeCBcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZHQpIHtcclxuICAgICAgICBpZiAodGhpcy5hbmltcylcclxuICAgICAgICAgICAgdGhpcy5hbmltcy51cGRhdGUoZHQpXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNwcml0ZSIsImltcG9ydCBHYW1lT2JqZWN0IGZyb20gXCIuL0dhbWVPYmplY3QuanNcIjtcblxuY2xhc3MgVGlsZVNwcml0ZSBleHRlbmRzIEdhbWVPYmplY3Qge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlID0gbnVsbCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZVxuICAgIHRoaXMuZnJhbWUgPSB7IHg6IDAsIHk6IDAsIHc6IHRleHR1cmUud2lkdGgsIGg6IHRleHR1cmUuaGVpZ2h0IH0gICAgXG4gIH1cblxuICBnZXQgdygpIHtcbiAgICByZXR1cm4gdGhpcy5mcmFtZS53ICogTWF0aC5hYnModGhpcy5zY2FsZS54KTtcbiAgfVxuXG4gIGdldCBoKCkge1xuICAgIHJldHVybiB0aGlzLmZyYW1lLmggKiBNYXRoLmFicyh0aGlzLnNjYWxlLnkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVTcHJpdGU7XG4iLCJpbXBvcnQgR2FtZU9iamVjdCBmcm9tIFwiLi9HYW1lT2JqZWN0LmpzXCJcclxuaW1wb3J0IHsgR3JhcGggfSBmcm9tIFwiLi9Db25zdGFudHMuanNcIlxyXG5cclxuY2xhc3MgUmVjdCBleHRlbmRzIEdhbWVPYmplY3Qge1xyXG4gICAgY29uc3RydWN0b3IodHlwZSA9IEdyYXBoLlJFQ1QpIHtcclxuICAgICAgICBzdXBlcigpXHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZVxyXG4gICAgICAgIHRoaXMudyBcclxuICAgICAgICB0aGlzLmggXHJcbiAgICAgICAgdGhpcy5zdHlsZSBcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVjdCIsImltcG9ydCBTcHJpdGUgZnJvbSBcIi4vU3ByaXRlLmpzXCJcclxuaW1wb3J0IFRpbGVTcHJpdGUgZnJvbSBcIi4vVGlsZVNwcml0ZS5qc1wiXHJcbmltcG9ydCB7IEdyYXBoLCBTY2FsZSB9IGZyb20gJy4vQ29uc3RhbnRzLmpzJ1xyXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi9SZWN0LmpzXCJcclxuXHJcbmNsYXNzIFJlbmRlciB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKVxyXG4gICAgICAgIHRoaXMudmlldyA9IGNhbnZhc1xyXG4gICAgICAgIHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKVxyXG4gICAgICAgIHRoaXMuY3R4LnRleHRCYXNlbGluZSA9IFwidG9wXCJcclxuICAgICAgICB0aGlzLm1vZGUgPSBjb25maWcubW9kZVxyXG4gICAgICAgIHRoaXMudyA9IHRoaXMudmlldy53aWR0aCA9IGNvbmZpZy53XHJcbiAgICAgICAgdGhpcy5oID0gdGhpcy52aWV3LmhlaWdodCA9IGNvbmZpZy5oXHJcbiAgICAgICAgdGhpcy5waXhlbCA9IGNvbmZpZy5waXhlbFxyXG4gICAgICAgIHRoaXMuY2hlY2tJc1BpeGVsQ29uZmlnKClcclxuICAgICAgICBpZiAodGhpcy5tb2RlID09PSBTY2FsZS5SRVNJWkUpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzaXplQ2FudmFzID0gdGhpcy5yZXNpemVDYW52YXMuYmluZCh0aGlzKVxyXG4gICAgICAgICAgICByZXNpemVDYW52YXMoKVxyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplQ2FudmFzLCBmYWxzZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKHNjZW5lLCBjbGVhciA9IHRydWUpIHtcclxuICAgICAgICBpZiAoc2NlbmUuYWN0aXZlID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgeyBjdHgsIHcsIGgsIG1vZGUgfSA9IHRoaXNcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVuZGVyUmVjKHNjZW5lLCBpc0ZpcnN0Tm9kZSA9IHRydWUpIHtcclxuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBjb250YWluZXIgY2hpbGRyZW5cclxuICAgICAgICAgICAgc2NlbmUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudmlzaWJsZSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSByZXNpemVcclxuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSBTY2FsZS5SRVNJWkUgJiYgaXNGaXJzdE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKE1hdGgucm91bmQoc2NlbmUucG9zLngpLCBNYXRoLnJvdW5kKHNjZW5lLnBvcy55KSlcclxuICAgICAgICAgICAgICAgICAgICAvLyBUTyBETzogSW1wcm92ZSB0aGlzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3ID4gd2luZG93LmlubmVyV2lkdGggJiYgaCA8IHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoKHdpbmRvdy5pbm5lcldpZHRoICogMTAwIC8gdykgLyAxMDAsICh3aW5kb3cuaW5uZXJXaWR0aCAqIDEwMCAvIHcpIC8gMTAwKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaCA+IHdpbmRvdy5pbm5lckhlaWdodCAmJiB3IDwgd2luZG93LmlubmVyV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKCh3aW5kb3cuaW5uZXJIZWlnaHQgKiAxMDAgLyBoKSAvIDEwMCwgKHdpbmRvdy5pbm5lckhlaWdodCAqIDEwMCAvIGgpIC8gMTAwKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodyA+IHdpbmRvdy5pbm5lcldpZHRoICYmIGggPiB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoID4gd2luZG93LmlubmVySGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKCh3aW5kb3cuaW5uZXJIZWlnaHQgKiAxMDAgLyBoKSAvIDEwMCwgKHdpbmRvdy5pbm5lckhlaWdodCAqIDEwMCAvIGgpIC8gMTAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoKHdpbmRvdy5pbm5lcldpZHRoICogMTAwIC8gdykgLyAxMDAsICh3aW5kb3cuaW5uZXJXaWR0aCAqIDEwMCAvIHcpIC8gMTAwKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LmlubmVySGVpZ2h0ID4gaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoKHdpbmRvdy5pbm5lckhlaWdodCAqIDEwMCAvIGgpIC8gMTAwLCAod2luZG93LmlubmVySGVpZ2h0ICogMTAwIC8gaCkgLyAxMDApXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0cmFuc2Zvcm1zXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQucG9zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShNYXRoLnJvdW5kKGNoaWxkLnBvcy54KSwgTWF0aC5yb3VuZChjaGlsZC5wb3MueSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuYW5jaG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjaGlsZC5hbmNob3IueCwgY2hpbGQuYW5jaG9yLnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKGNoaWxkLnNjYWxlLngsIGNoaWxkLnNjYWxlLnkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQucm90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBweCA9IGNoaWxkLnBpdm90ID8gY2hpbGQucGl2b3QueCA6IDBcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBweSA9IGNoaWxkLnBpdm90ID8gY2hpbGQucGl2b3QueSA6IDBcclxuICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHB4LCBweSlcclxuICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKGNoaWxkLnJvdGF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXB4LCAtcHkpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRHJhdyB0aGUgbGVhZiBub2Rlc1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZvbnQsIGZpbGwsIGFsaWduIH0gPSBjaGlsZC5zdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb250KSBjdHguZm9udCA9IGZvbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsbCkgY3R4LmZpbGxTdHlsZSA9IGZpbGxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpZ24pIGN0eC50ZXh0QWxpZ24gPSBhbGlnblxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChjaGlsZC50ZXh0LCAwLCAwKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFNwcml0ZSB8fCBjaGlsZCBpbnN0YW5jZW9mIFRpbGVTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWcgPSBjaGlsZC50ZXh0dXJlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5mcmFtZS54ICogY2hpbGQuZnJhbWUudyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmZyYW1lLnkgKiBjaGlsZC5mcmFtZS5oLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZnJhbWUudyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmZyYW1lLmgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmZyYW1lLncsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5mcmFtZS5oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBSZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEdyYXBoLlJFQ1QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmaWxsIH0gPSBjaGlsZC5zdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNoaWxkLncsIGNoaWxkLmgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gR3JhcGguUkVDVF9PVVRMSU5FKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmlsbCwgbGluZVdpZHRoIH0gPSBjaGlsZC5zdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBmaWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KDAsIDAsIGNoaWxkLncsIGNoaWxkLmgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgYW55IGNoaWxkIHN1Yi1ub2Rlc1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyUmVjKGNoaWxkLCBmYWxzZSlcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2xlYXIpIHtcclxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJSZWMoc2NlbmUpXHJcbiAgICB9XHJcblxyXG4gICAgcmVzaXplQ2FudmFzKCkge1xyXG4gICAgICAgIHRoaXMudmlldy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXHJcbiAgICAgICAgdGhpcy52aWV3LmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxyXG4gICAgICAgIHRoaXMuY2hlY2tJc1BpeGVsQ29uZmlnKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrSXNQaXhlbENvbmZpZygpIHtcclxuICAgICAgICBpZiAodGhpcy5waXhlbCkge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaW1hZ2VSZW5kZXJpbmcgPSAncGl4ZWxhdGVkJ1xyXG4gICAgICAgICAgICB0aGlzLmN0eC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZVxyXG4gICAgICAgICAgICB0aGlzLmN0eC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZVxyXG4gICAgICAgICAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyXHJcblxyXG4iLCJjbGFzcyBLZXlDb250cm9scyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmtleXMgPSB7fVxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGUgPT4ge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpcyBhIHRyaWNrIHRvIHN0b3AgdGhlIGJyb3dzZXIgc2Nyb2xsaW5nIGlmIHRoZSBnYW1lIGlzIGVtYmVkZGVkIGluIGEgd2ViIHBhZ2UgdGhhdCBoYXMgc2Nyb2xsYmFyc1xyXG4gICAgICAgICAgICBpZiAoWzM3LCAzOCwgMzksIDQwLCAzMl0uaW5kZXhPZihlLndoaWNoKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmtleXNbZS5rZXlDb2RlXSA9IHRydWVcclxuICAgICAgICB9LCBmYWxzZSlcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmtleXNbZS53aGljaF0gPSBmYWxzZVxyXG4gICAgICAgIH0sIGZhbHNlKVxyXG4gICAgfVxyXG5cclxuICAgIGtleShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5rZXlzW2tleV0gPSB2YWx1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5rZXlzW2tleV1cclxuICAgIH1cclxuXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5rZXlzKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2V5c1trZXldID0gZmFsc2VcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlIGtleSBhY3Rpb25zXHJcbiAgICBnZXQgYWN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmtleXNbMzJdXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHgoKSB7XHJcbiAgICAgICAgLy8gbGVmdCBhcnJvdyBvciBBIGtleVxyXG4gICAgICAgIGlmICh0aGlzLmtleXNbMzddIHx8IHRoaXMua2V5c1s2NV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJpZ2h0IGFycm93IG9yIEQga2V5XHJcbiAgICAgICAgaWYgKHRoaXMua2V5c1szOV0gfHwgdGhpcy5rZXlzWzY4XSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMFxyXG4gICAgfVxyXG5cclxuICAgIGdldCB5KCkge1xyXG4gICAgICAgIC8vIHVwIGFycm93IG9yIFcga2V5XHJcbiAgICAgICAgaWYgKHRoaXMua2V5c1szOF0gfHwgdGhpcy5rZXlzWzg3XSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTFcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZG93biBhcnJvdyBvciBTIGtleVxyXG4gICAgICAgIGlmICh0aGlzLmtleXNbNDBdIHx8IHRoaXMua2V5c1s4M10pIHtcclxuICAgICAgICAgICAgcmV0dXJuIDFcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDBcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgTW91c2VDb250cm9scyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmVsID0gY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHk7XHJcblxyXG4gICAgICAgIHRoaXMucG9zID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgdGhpcy5pc0Rvd24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZXJzXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlID0+IHRoaXMuZG93bihlKSwgZmFsc2UpO1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGUgPT4gdGhpcy51cChlKSwgZmFsc2UpO1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZSA9PiB0aGlzLm1vdmUoZSksIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBtb3VzZVBvc0Zyb21FdmVudCh7IGNsaWVudFgsIGNsaWVudFkgfSkge1xyXG4gICAgICAgIGNvbnN0IHsgZWwsIHBvcyB9ID0gdGhpc1xyXG4gICAgICAgIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG4gICAgICAgIGNvbnN0IHhyID0gZWwud2lkdGggLyBlbC5jbGllbnRXaWR0aFxyXG4gICAgICAgIGNvbnN0IHlyID0gZWwuaGVpZ2h0IC8gZWwuY2xpZW50SGVpZ2h0XHJcbiAgICAgICAgcG9zLnggPSAoY2xpZW50WCAtIHJlY3QubGVmdCkgKiB4clxyXG4gICAgICAgIHBvcy55ID0gKGNsaWVudFkgLSByZWN0LnRvcCkgKiB5clxyXG4gICAgfVxyXG5cclxuICAgIGRvd24oZSkge1xyXG4gICAgICAgIHRoaXMuaXNEb3duID0gdHJ1ZVxyXG4gICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWVcclxuICAgICAgICB0aGlzLm1vdXNlUG9zRnJvbUV2ZW50KGUpXHJcbiAgICB9XHJcblxyXG4gICAgdXAoKSB7XHJcbiAgICAgICAgdGhpcy5pc0Rvd24gPSBmYWxzZVxyXG4gICAgICAgIHRoaXMucmVsZWFzZWQgPSB0cnVlXHJcbiAgICB9XHJcblxyXG4gICAgbW92ZShlKSB7XHJcbiAgICAgICAgdGhpcy5tb3VzZVBvc0Zyb21FdmVudChlKVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2VcclxuICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQge1xyXG4gICAgS2V5Q29udHJvbHMsXHJcbiAgICBNb3VzZUNvbnRyb2xzXHJcbn1cclxuIiwiaW1wb3J0IEdhbWVPYmplY3QgZnJvbSBcIi4vR2FtZU9iamVjdC5qc1wiXHJcblxyXG5jbGFzcyBUZXh0IGV4dGVuZHMgR2FtZU9iamVjdCB7XHJcbiAgY29uc3RydWN0b3IodGV4dCA9IFwiXCIpIHtcclxuICAgIHN1cGVyKClcclxuICAgIHRoaXMudGV4dCA9IHRleHRcclxuICAgIHRoaXMuc3R5bGVcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRleHQiLCJpbXBvcnQgQ29udGFpbmVyIGZyb20gXCIuL0NvbnRhaW5lci5qc1wiXHJcbmltcG9ydCBUZXh0IGZyb20gXCIuL1RleHQuanNcIlxyXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi9SZWN0LmpzXCJcclxuaW1wb3J0IHsgR3JhcGggfSBmcm9tIFwiLi9Db25zdGFudHMuanNcIlxyXG5cclxuY2xhc3MgRGVidWcgZXh0ZW5kcyBDb250YWluZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKVxyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2VcclxuICAgICAgICBjb25zdCBmcHNUeHQgPSBuZXcgVGV4dCgnZnBzOiAnKVxyXG4gICAgICAgIGZwc1R4dC5uYW1lID0gJ2ZwcydcclxuICAgICAgICBmcHNUeHQucG9zID0geyB4OiA1LCB5OiAxNSB9XHJcbiAgICAgICAgZnBzVHh0LnN0eWxlID0geyBmb250OiAnMTZweCBBcmlhbCcsIGZpbGw6ICdyZWQnLCBhbGlnbjogJ2xlZnQnIH1cclxuICAgICAgICB0aGlzLmFkZChmcHNUeHQpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkRGVidWcoZSkge1xyXG4gICAgLy8gICAgIGUuY2hpbGRyZW4gPSBlLmNoaWxkcmVuIHx8IFtdXHJcbiAgICAvLyAgICAgY29uc3QgaSA9IG5ldyBSZWN0KEdyYXBoLlJFQ1RfT1VUTElORSlcclxuICAgIC8vICAgICBpLncgPSBlLmZyYW1lLndcclxuICAgIC8vICAgICBpLmggPSBlLmZyYW1lLmhcclxuICAgIC8vICAgICBpLnN0eWxlID0geyBmaWxsOiAnY3lhbicsIGxpbmVXaWR0aDogMSB9XHJcbiAgICAvLyAgICAgZS5jaGlsZHJlbi5wdXNoKGkpXHJcbiAgICAvLyAgICAgaWYgKGUuaGl0Qm94KSB7XHJcbiAgICAvLyAgICAgICAgIGNvbnN0IHsgeCwgeSwgdywgaCB9ID0gZS5oaXRCb3g7XHJcbiAgICAvLyAgICAgICAgIGNvbnN0IGhiID0gbmV3IFJlY3QoR3JhcGguUkVDVF9PVVRMSU5FKVxyXG4gICAgLy8gICAgICAgICBoYi5zdHlsZSA9IHsgZmlsbDogJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJyB9XHJcbiAgICAvLyAgICAgICAgIGhiLm5hbWUgPSBcImhiXCJcclxuICAgIC8vICAgICAgICAgaGIudyA9IHdcclxuICAgIC8vICAgICAgICAgaGIuaCA9IGhcclxuICAgIC8vICAgICAgICAgaGIucG9zID0geyB4LCB5IH1cclxuICAgIC8vICAgICAgICAgZS5jaGlsZHJlbi5wdXNoKGhiKTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9XHJcbiAgICBhZGREZWJ1ZyhlKSB7XHJcbiAgICAgICAgZS5jaGlsZHJlbiA9IGUuY2hpbGRyZW4gfHwgW11cclxuICAgICAgICBjb25zdCBpID0gbmV3IFJlY3QoR3JhcGguUkVDVF9PVVRMSU5FKVxyXG4gICAgICAgIGkudyA9IGUuZnJhbWUud1xyXG4gICAgICAgIGkuaCA9IGUuZnJhbWUuaFxyXG4gICAgICAgIGkuc3R5bGUgPSB7IGZpbGw6ICdjeWFuJywgbGluZVdpZHRoOiAxIH1cclxuICAgICAgICBlLmNoaWxkcmVuLnB1c2goaSlcclxuICAgICAgICBpZiAoZS5ib2R5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgdywgaCB9ID0gZS5ib2R5XHJcbiAgICAgICAgICAgIGNvbnN0IGhiID0gbmV3IFJlY3QoR3JhcGguUkVDVF9PVVRMSU5FKVxyXG4gICAgICAgICAgICBoYi5zdHlsZSA9IHsgZmlsbDogJ3JnYmEoMjU1LCAwLCAwLCAxKScgfVxyXG4gICAgICAgICAgICBoYi5uYW1lID0gXCJoYlwiXHJcbiAgICAgICAgICAgIGhiLncgPSB3XHJcbiAgICAgICAgICAgIGhiLmggPSBoXHJcbiAgICAgICAgICAgIGhiLnBvcyA9IHsgeCwgeSB9XHJcbiAgICAgICAgICAgIGUuY2hpbGRyZW4ucHVzaChoYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEZWJ1ZyIsImltcG9ydCBSZW5kZXJlciBmcm9tIFwiLi9SZW5kZXJlci5qc1wiXHJcbmltcG9ydCB7IEtleUNvbnRyb2xzLCBNb3VzZUNvbnRyb2xzIH0gZnJvbSBcIi4vSW5wdXRzLmpzXCJcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuL0RlYnVnLmpzXCJcclxuXHJcbmNsYXNzIEdhbWUge1xyXG5cclxuICBzdGVwID0gMSAvIDYwXHJcbiAgTUFYX0ZSQU1FID0gdGhpcy5zdGVwICogNVxyXG5cclxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgIHRoaXMudyA9IGNvbmZpZy53XHJcbiAgICB0aGlzLmggPSBjb25maWcuaFxyXG4gICAgdGhpcy5yZW5kZXJlciA9IHRoaXMuY3JlYXRlUmVuZGVyZXIoY29uZmlnKVxyXG4gICAgdGhpcy5zY2VuZXMgPSBbXVxyXG4gICAgdGhpcy5zY2VuZVxyXG4gICAgdGhpcy50ZXh0dXJlc1xyXG4gICAgdGhpcy5jb250cm9scyA9IG5ldyBLZXlDb250cm9scygpXHJcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlQ29udHJvbHModGhpcy5yZW5kZXJlci52aWV3KVxyXG4gICAgdGhpcy5kZWJ1ZyA9IG5ldyBEZWJ1ZygpXHJcbiAgICB0aGlzLmRlYnVnLmFjdGl2ZSA9IGNvbmZpZy5kZWJ1Z01vZGVcclxuICB9XHJcblxyXG4gIGFkZFNjZW5lKHNjZW5lKSB7XHJcbiAgICBpZiAodGhpcy5kZWJ1Zy5hY3RpdmUpXHJcbiAgICAgIHNjZW5lLmFkZCh0aGlzLmRlYnVnKVxyXG5cclxuICAgIGlmICghdGhpcy5zY2VuZSlcclxuICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lXHJcblxyXG4gICAgdGhpcy5zY2VuZXMucHVzaChzY2VuZSlcclxuICB9XHJcblxyXG4gIGxhdW5jaFNjZW5lKHNjZW5lTmFtZSkge1xyXG4gICAgdGhpcy5zY2VuZSA9IHRoaXMuc2NlbmVzLmZpbmQocyA9PiBzLmtleSA9PT0gc2NlbmVOYW1lKVxyXG4gICAgdGhpcy5zY2VuZS5pbml0KClcclxuICB9XHJcblxyXG4gIHJ1bihnYW1lVXBkYXRlID0gKCkgPT4geyB9KSB7XHJcbiAgICBjb25zdCB7IE1BWF9GUkFNRSB9ID0gdGhpc1xyXG4gICAgbGV0IGR0ID0gMFxyXG4gICAgbGV0IGxhc3QgPSAwXHJcbiAgICBsZXQgZnBzID0gMFxyXG5cclxuICAgIGNvbnN0IG1haW5sb29wID0gbXMgPT4ge1xyXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobWFpbmxvb3ApXHJcbiAgICAgIC8vIGNyZWF0ZSBkZWx0YVxyXG4gICAgICBjb25zdCB0ID0gbXMgLyAxMDAwXHJcbiAgICAgIGR0ID0gTWF0aC5taW4odCAtIGxhc3QsIE1BWF9GUkFNRSlcclxuICAgICAgbGFzdCA9IHRcclxuICAgICAgZnBzID0gTWF0aC5yb3VuZCgxIC8gZHQpXHJcblxyXG4gICAgICBpZiAoIXRoaXMuc2NlbmUgJiYgdGhpcy5kZWJ1Zy5hY3RpdmUpXHJcbiAgICAgICAgcmV0dXJuXHJcblxyXG4gICAgICBpZiAodGhpcy5kZWJ1Zy5hY3RpdmUpXHJcbiAgICAgICAgdGhpcy5zY2VuZS5jaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkIGluc3RhbmNlb2YgRGVidWcpLmNoaWxkcmVuLmZpbmQoYyA9PiBjLm5hbWUgPT09IFwiZnBzXCIpLnRleHQgPSAnZnBzLTogJyArIGZwc1xyXG5cclxuICAgICAgdGhpcy5zY2VuZS51cGRhdGUoZHQsIHQpXHJcbiAgICAgIGdhbWVVcGRhdGUoZHQsIHQsIHRoaXMuY29udHJvbHMpXHJcbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUpXHJcblxyXG4gICAgfVxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1haW5sb29wKVxyXG4gIH1cclxuXHJcbiAgY3JlYXRlUmVuZGVyZXIoY29uZmlnKSB7XHJcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBSZW5kZXJlcihjb25maWcpXHJcbiAgICBjb25zdCBwYXJlbnQgPSBjb25maWcucGFyZW50IHx8IFwiZ2FtZVwiXHJcbiAgICBsZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbmZpZy5wYXJlbnQpXHJcbiAgICBpZiAoIWVsKSB7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuaW5uZXJIVE1MID0gJzxkaXYgaWQ9XCInICsgcGFyZW50ICsgJ1wiPjwvZGl2PidcclxuICAgIH1cclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmVudCkuYXBwZW5kQ2hpbGQocmVuZGVyZXIudmlldylcclxuICAgIHJldHVybiByZW5kZXJlcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdhbWUiLCJjbGFzcyBUZXh0dXJlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1cmxzKSB7XHJcbiAgICAgICAgdGhpcy51cmxzID0gdXJsc1xyXG4gICAgICAgIHRoaXMuaW1ncyA9IHt9XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZChjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnVybHMubWFwKGkgPT4gdGhpcy5sb2FkSW1hZ2UoaSkpXHJcbiAgICAgICAgUHJvbWlzZS5hbGwocClcclxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBvID0gdGhpcy5pbWdzID0gT2JqZWN0LmFzc2lnbiguLi5yZXMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGxvYWRJbWFnZShpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKClcclxuICAgICAgICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbyA9IHsgW2lbMF1dOiBpbWcgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShvKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3aGVuIGxvYWRpbmcgYW4gaW1hZ2UnKVxyXG4gICAgICAgICAgICAgICAgcmVqZWN0KClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgaW1nLnNyYyA9IGlbMV1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUZXh0dXJlTWFuYWdlciIsImltcG9ydCBDb250YWluZXIgZnJvbSBcIi4vQ29udGFpbmVyLmpzXCI7XHJcbmltcG9ydCBUaWxlU3ByaXRlIGZyb20gXCIuL1RpbGVTcHJpdGUuanNcIjtcclxuXHJcbmNsYXNzIFRpbGVNYXAgZXh0ZW5kcyBDb250YWluZXIge1xyXG4gIGNvbnN0cnVjdG9yKHRleHR1cmUgPSBudWxsKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5tYXBXXHJcbiAgICB0aGlzLm1hcEhcclxuICAgIHRoaXMudGlsZVdcclxuICAgIHRoaXMudGlsZUhcclxuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmVcclxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXVxyXG4gIH1cclxuXHJcbiAgYWRkVGlsZXModGlsZXMsIHNjYWxlID0gMSkge1xyXG4gICAgLy8gQWRkIGFsbCB0aWxlIHNwcml0ZXNcclxuICAgIHRoaXMuY2hpbGRyZW4gPSB0aWxlcy5tYXAoKGZyYW1lLCBpKSA9PiB7XHJcbiAgICAgIGNvbnN0IHMgPSBuZXcgVGlsZVNwcml0ZSh0aGlzLnRleHR1cmUpXHJcbiAgICAgIHMuZnJhbWUgPVxyXG4gICAgICB7XHJcbiAgICAgICAgLi4uZnJhbWUsXHJcbiAgICAgICAgdzogdGhpcy50aWxlVyxcclxuICAgICAgICBoOiB0aGlzLnRpbGVIXHJcbiAgICAgIH1cclxuICAgICAgcy5zY2FsZSA9IHsgeDogc2NhbGUsIHk6IHNjYWxlIH1cclxuICAgICAgcy5wb3MueCA9IGkgJSB0aGlzLm1hcFcgKiB0aGlzLnRpbGVXXHJcbiAgICAgIHMucG9zLnkgPSBNYXRoLmZsb29yKGkgLyB0aGlzLm1hcFcpICogdGhpcy50aWxlSFxyXG5cclxuICAgICAgcmV0dXJuIHM7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHBpeGVsVG9NYXBQb3MocG9zKSB7XHJcbiAgICBjb25zdCB7IHRpbGVXLCB0aWxlSCB9ID0gdGhpc1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogTWF0aC5mbG9vcihwb3MueCAvIHRpbGVXKSxcclxuICAgICAgeTogTWF0aC5mbG9vcihwb3MueSAvIHRpbGVIKVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIG1hcFRvUGl4ZWxQb3MobWFwUG9zKSB7XHJcbiAgICBjb25zdCB7IHRpbGVXLCB0aWxlSCB9ID0gdGhpcztcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IG1hcFBvcy54ICogdGlsZVcsXHJcbiAgICAgIHk6IG1hcFBvcy55ICogdGlsZUhcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB0aWxlQXRNYXBQb3MobWFwUG9zKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblttYXBQb3MueSAqIHRoaXMubWFwVyArIG1hcFBvcy54XTtcclxuICB9XHJcblxyXG4gIHRpbGVBdFBpeGVsUG9zKHBvcykge1xyXG4gICAgcmV0dXJuIHRoaXMudGlsZUF0TWFwUG9zKHRoaXMucGl4ZWxUb01hcFBvcyhwb3MpKTtcclxuICB9XHJcblxyXG4gIHNldEZyYW1lQXRNYXBQb3MobWFwUG9zLCBmcmFtZSkge1xyXG4gICAgY29uc3QgdGlsZSA9IHRoaXMudGlsZUF0TWFwUG9zKG1hcFBvcyk7XHJcbiAgICB0aWxlLmZyYW1lID0gZnJhbWU7XHJcbiAgICByZXR1cm4gdGlsZTtcclxuICB9XHJcblxyXG4gIHNldEZyYW1lQXRQaXhlbFBvcyhwb3MsIGZyYW1lKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRGcmFtZUF0TWFwUG9zKHRoaXMucGl4ZWxUb01hcFBvcyhwb3MpLCBmcmFtZSk7XHJcbiAgfVxyXG5cclxuICB0aWxlc0F0Q29ybmVycyhib3VuZHMsIHhvID0gMCwgeW8gPSAwKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBbYm91bmRzLngsIGJvdW5kcy55XSwgLy8gVG9wLWxlZnRcclxuICAgICAgW2JvdW5kcy54ICsgYm91bmRzLncsIGJvdW5kcy55XSwgLy8gVG9wLXJpZ2h0XHJcbiAgICAgIFtib3VuZHMueCwgYm91bmRzLnkgKyBib3VuZHMuaF0sIC8vIEJvdHRvbS1sZWZ0XHJcbiAgICAgIFtib3VuZHMueCArIGJvdW5kcy53LCBib3VuZHMueSArIGJvdW5kcy5oXSAvLyBCb3R0b20tcmlnaHRcclxuICAgIF0ubWFwKChbeCwgeV0pID0+XHJcbiAgICAgIHRoaXMudGlsZUF0UGl4ZWxQb3Moe1xyXG4gICAgICAgIHg6IHggKyB4byxcclxuICAgICAgICB5OiB5ICsgeW9cclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUaWxlTWFwO1xyXG4iLCJpbXBvcnQgQ29udGFpbmVyIGZyb20gXCIuL0NvbnRhaW5lci5qc1wiXHJcbmltcG9ydCBtYXRoIGZyb20gXCIuL3V0aWxzLmpzXCJcclxuXHJcbmNsYXNzIENhbWVyYSBleHRlbmRzIENvbnRhaW5lciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzdWJqZWN0LCB2aWV3cG9ydCwgd29ybGRTaXplID0gdmlld3BvcnQpIHtcclxuICAgICAgICBzdXBlcigpXHJcbiAgICAgICAgdGhpcy53ID0gdmlld3BvcnQud1xyXG4gICAgICAgIHRoaXMuaCA9IHZpZXdwb3J0LmhcclxuICAgICAgICB0aGlzLndvcmxkU2l6ZSA9IHdvcmxkU2l6ZVxyXG4gICAgICAgIHRoaXMuc2V0U3ViamVjdChzdWJqZWN0KVxyXG4gICAgfVxyXG5cclxuICAgIHNldFN1YmplY3QoZSkge1xyXG4gICAgICAgIHRoaXMuc3ViamVjdCA9IGUgPyBlLnBvcyB8fCBlIDogdGhpcy5wb3NcclxuICAgICAgICB0aGlzLm9mZnNldCA9IHsgeDogMCwgeTogMCB9XHJcblxyXG4gICAgICAgIC8vIENlbnRlciBvbiB0aGUgZW50aXR5XHJcbiAgICAgICAgaWYgKGUgJiYgZS5mcmFtZS53KSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0LnggKz0gZS5mcmFtZS53IC8gMlxyXG4gICAgICAgICAgICB0aGlzLm9mZnNldC55ICs9IGUuZnJhbWUuaCAvIDJcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGUgJiYgZS5hbmNob3IpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQueCAtPSBlLmFuY2hvci54XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0LnkgLT0gZS5hbmNob3IueVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZvY3VzKClcclxuICAgIH1cclxuXHJcbiAgICBmb2N1cygpIHtcclxuICAgICAgICBjb25zdCB7IHBvcywgdywgaCwgd29ybGRTaXplLCBzdWJqZWN0LCBvZmZzZXQgfSA9IHRoaXNcclxuXHJcbiAgICAgICAgY29uc3QgY2VudGVyZWRYID0gc3ViamVjdC54ICsgb2Zmc2V0LnggLSAodyAvIDIpXHJcbiAgICAgICAgY29uc3QgbWF4WCA9IHdvcmxkU2l6ZS53IC0gd1xyXG4gICAgICAgIGNvbnN0IHggPSAtbWF0aC5jbGFtcChjZW50ZXJlZFgsIDAsIG1heFgpXHJcblxyXG4gICAgICAgIGNvbnN0IGNlbnRlcmVkWSA9IHN1YmplY3QueSArIG9mZnNldC55IC0gaCAvIDJcclxuICAgICAgICBjb25zdCBtYXhZID0gd29ybGRTaXplLmggLSBoXHJcbiAgICAgICAgY29uc3QgeSA9IC1tYXRoLmNsYW1wKGNlbnRlcmVkWSwgMCwgbWF4WSlcclxuXHJcbiAgICAgICAgcG9zLnggPSB4XHJcbiAgICAgICAgcG9zLnkgPSB5XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKGR0LCB0KSB7XHJcbiAgICAgICAgc3VwZXIudXBkYXRlKGR0LCB0KVxyXG5cclxuICAgICAgICBpZiAodGhpcy5zdWJqZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FtZXJhXHJcbiIsImZ1bmN0aW9uIHdhbGxzbGlkZShlbnQsIG1hcCwgeCA9IDAsIHkgPSAwKSB7XG4gIGxldCB0aWxlc1xuICBsZXQgdGlsZUVkZ2VcblxuICBjb25zdCB7IGhpdEJveCwgcG9zIH0gPSBlbnRcbiAgY29uc3QgaGl0ID0gaGl0Qm94XG5cbiAgY29uc3QgYm91bmRzID0ge1xuICAgIHg6IGhpdC54ICsgcG9zLngsXG4gICAgeTogaGl0LnkgKyBwb3MueSxcbiAgICB3OiBoaXQudyxcbiAgICBoOiBoaXQuaFxuICB9XG5cbiAgLy8gRmluYWwgYW1vdW50cyBvZiBtb3ZlbWVudCB0byBhbGxvd1xuICBsZXQgeG8gPSB4XG4gIGxldCB5byA9IHlcblxuICAvLyBDaGVjayB2ZXJ0aWNhbCBtb3ZlbWVudFxuICBpZiAoeSAhPT0gMCkge1xuICAgIHRpbGVzID0gbWFwLnRpbGVzQXRDb3JuZXJzKGJvdW5kcywgMCwgeW8pXG4gICAgY29uc3QgW3RsLCB0ciwgYmwsIGJyXSA9IHRpbGVzLm1hcCh0ID0+IHQgJiYgdC5mcmFtZS5yaWdpZClcblxuICAgIC8vIEhpdCB5b3VyIGhlYWRcbiAgICBpZiAoeSA8IDAgJiYgISh0bCAmJiB0cikpIHtcbiAgICAgIHRpbGVFZGdlID0gdGlsZXNbMF0ucG9zLnkgKyB0aWxlc1swXS5mcmFtZS5oXG4gICAgICB5byA9IHRpbGVFZGdlIC0gYm91bmRzLnkgKyAxXG4gICAgfVxuICAgIC8vIEhpdCB5b3VyIGZlZXRcbiAgICBpZiAoeSA+IDAgJiYgIShibCAmJiBicikpIHtcbiAgICAgIHRpbGVFZGdlID0gdGlsZXNbMl0ucG9zLnkgLSAxXG4gICAgICB5byA9IHRpbGVFZGdlIC0gKGJvdW5kcy55ICsgYm91bmRzLmgpXG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaG9yaXpvbnRhbCBtb3ZlbWVudFxuICBpZiAoeCAhPT0gMCkge1xuICAgIHRpbGVzID0gbWFwLnRpbGVzQXRDb3JuZXJzKGJvdW5kcywgeG8sIHlvKVxuICAgIGNvbnN0IFt0bCwgdHIsIGJsLCBicl0gPSB0aWxlcy5tYXAodCA9PiB0ICYmIHQuZnJhbWUucmlnaWQpXG5cbiAgICAvLyBIaXQgbGVmdCBlZGdlXG4gICAgaWYgKHggPCAwICYmICEodGwgJiYgYmwpKSB7XG4gICAgICB0aWxlRWRnZSA9IHRpbGVzWzBdLnBvcy54ICsgdGlsZXNbMF0uZnJhbWUud1xuICAgICAgeG8gPSB0aWxlRWRnZSAtIGJvdW5kcy54ICsgMVxuICAgIH1cbiAgICAvLyBIaXQgcmlnaHQgZWRnZVxuICAgIGlmICh4ID4gMCAmJiAhKHRyICYmIGJyKSkge1xuICAgICAgdGlsZUVkZ2UgPSB0aWxlc1sxXS5wb3MueCAtIDFcbiAgICAgIHhvID0gdGlsZUVkZ2UgLSAoYm91bmRzLnggKyBib3VuZHMudylcbiAgICB9XG4gIH1cbiAgLy8geG8gJiB5byBjb250YWluIHRoZSBhbW91bnQgd2UncmUgYWxsb3dlZCB0byBtb3ZlIGJ5LlxuICByZXR1cm4geyB4OiB4bywgeTogeW8gfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3YWxsc2xpZGVcbiIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi9TY2VuZS5qc1wiXHJcbmltcG9ydCBHYW1lIGZyb20gXCIuL0dhbWUuanNcIlxyXG5pbXBvcnQgVGV4dCBmcm9tIFwiLi9UZXh0LmpzXCJcclxuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi9TcHJpdGUuanNcIlxyXG5pbXBvcnQgVGV4dHVyZU1hbmFnZXIgZnJvbSBcIi4vVGV4dHVyZU1hbmFnZXIuanNcIlxyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gXCIuL0NvbnRhaW5lci5qc1wiXHJcbmltcG9ydCBUaWxlTWFwIGZyb20gXCIuL1RpbGVNYXAuanNcIlxyXG5pbXBvcnQgQ2FtZXJhIGZyb20gXCIuL0NhbWVyYS5qc1wiXHJcbmltcG9ydCAgUmVjdCAgZnJvbSBcIi4vUmVjdC5qc1wiXHJcbmltcG9ydCB7IFNjYWxlLCBTdGF0ZSwgR3JhcGggfSBmcm9tIFwiLi9Db25zdGFudHMuanNcIlxyXG5pbXBvcnQgbWF0aCBmcm9tIFwiLi91dGlscy5qc1wiXHJcbmltcG9ydCB3YWxsc2xpZGUgIGZyb20gXCIuL3dhbGxzbGlkZS5qc1wiXHJcblxyXG5leHBvcnQge1xyXG4gICAgR2FtZSxcclxuICAgIFNjZW5lLFxyXG4gICAgVGV4dCxcclxuICAgIFNwcml0ZSxcclxuICAgIFRleHR1cmVNYW5hZ2VyLFxyXG4gICAgQ29udGFpbmVyLFxyXG4gICAgVGlsZU1hcCxcclxuICAgIENhbWVyYSxcclxuICAgIFJlY3QsXHJcbiAgICBTY2FsZSxcclxuICAgIFN0YXRlLFxyXG4gICAgR3JhcGgsXHJcbiAgICBtYXRoLFxyXG4gICAgd2FsbHNsaWRlXHJcbn0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQUlBOztBQ2hDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBRkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU1BO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7Ozs7QUE5QkE7QUFDQTtBQWdDQTs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUNiQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFFQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBVUE7QUFDQTs7O0FBZ0NBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBSUE7OztBQUVBO0FBQ0E7QUFFQTs7O0FBM0VBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOzs7O0FBMUNBO0FBQ0E7QUEwRkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9GQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSEE7QUFJQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7OztBQWJBO0FBQ0E7QUFlQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFNQTtBQUNBOztBQVJBO0FBQ0E7QUFTQTs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUdBOzs7Ozs7OztBQ2pKQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckdBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUhBO0FBSUE7QUFDQTs7QUFOQTtBQUNBO0FBT0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFSQTtBQVFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBOUNBO0FBQ0E7QUFnREE7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3RUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFRQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUpBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFKQTtBQUtBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBRkE7QUFEQTtBQU1BOzs7O0FBM0VBO0FBQ0E7QUE2RUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU5BO0FBTUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQTlDQTtBQUNBO0FBZ0RBOzs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUVBO0FBQUE7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFFQTtBQUFBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///775\n')}},__webpack_module_cache__={};function __webpack_require__(e){if(__webpack_module_cache__[e])return __webpack_module_cache__[e].exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}return __webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},__webpack_require__(775)})()}));